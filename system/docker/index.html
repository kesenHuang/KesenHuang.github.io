<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>docker | Kesen’s Blog</title><meta name="keywords" content="docker"><meta name="author" content="Kesen"><meta name="copyright" content="Kesen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="容器生态系统 容器核心技术容器核心技术是指能够让Contailer在host上运行起来的技术。  容器规范容器不光是 Docker ，还有其他容器，比如CoreOS 的 rkt. 为了保证容器生态的健康发 展，保证不同容器之间能够兼容，包含 Docker 、Core08、Google 在内的若干公司共同成立了 一 个叫 Open Container lnitiative (OCI)  的组织，其目">
<meta property="og:type" content="article">
<meta property="og:title" content="docker">
<meta property="og:url" content="http://example.com/system/docker/index.html">
<meta property="og:site_name" content="Kesen’s Blog">
<meta property="og:description" content="容器生态系统 容器核心技术容器核心技术是指能够让Contailer在host上运行起来的技术。  容器规范容器不光是 Docker ，还有其他容器，比如CoreOS 的 rkt. 为了保证容器生态的健康发 展，保证不同容器之间能够兼容，包含 Docker 、Core08、Google 在内的若干公司共同成立了 一 个叫 Open Container lnitiative (OCI)  的组织，其目">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/11/15/o6eL9Fk8DZqIJY7.png">
<meta property="article:published_time" content="2021-01-24T04:43:39.000Z">
<meta property="article:modified_time" content="2021-11-15T02:03:06.968Z">
<meta property="article:author" content="Kesen">
<meta property="article:tag" content="docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/11/15/o6eL9Fk8DZqIJY7.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/system/docker/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2021-11-15 10:03:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}const fontSizeVal = saveToLocal.get('global-font-size')
if (fontSizeVal !== undefined) {
  document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
}})()</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Kesen’s Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2021/11/15/o6eL9Fk8DZqIJY7.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Kesen’s Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">docker</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-01-24T04:43:39.000Z" title="发表于 2021-01-24 12:43:39">2021-01-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-15T02:03:06.968Z" title="更新于 2021-11-15 10:03:06">2021-11-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BA%91%E6%8A%80%E6%9C%AF/">云技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="容器生态系统"><a href="#容器生态系统" class="headerlink" title="容器生态系统"></a>容器生态系统</h2><p><img src="https://i.loli.net/2021/01/24/6NjQbWXVq3KD8nz.png"></p>
<h3 id="容器核心技术"><a href="#容器核心技术" class="headerlink" title="容器核心技术"></a>容器核心技术</h3><p>容器核心技术是指能够让Contailer在host上运行起来的技术。</p>
<p><img src="https://i.loli.net/2021/01/24/SUMo2xCn5tcWIAb.png"></p>
<h4 id="容器规范"><a href="#容器规范" class="headerlink" title="容器规范"></a>容器规范</h4><p>容器不光是 Docker ，还有其他容器，比如CoreOS 的 rkt. 为了保证容器生态的健康发 展，保证不同容器之间能够兼容，包含 Docker 、Core08、Google 在内的若干公司共同成立了 一 个叫 Open Container lnitiative (OCI)  的组织，其目的是制定开放的容器规范。</p>
<p>目前 OCI  发布了两个规范: <code>runtime spec</code>  和<code> image format spec</code>.</p>
<p> 有了这两个规范，不同组织和厂商开发的容器能够在不同的   runtime   上运行 .这样就保证了容器的可移植性和互操作性。</p>
<h4 id="容器的runtime"><a href="#容器的runtime" class="headerlink" title="容器的runtime"></a>容器的runtime</h4><p>Java 程序就好比是容器， 只叫则好比是 runtime ，JVM  为 Java  程序提供运行环境。同样的道理，容器只有在 runtime  中才能运行。</p>
<p><code>lxc</code>、<code>runc</code> 和 <code>rkt</code> 是目前主流的三种容器 runtime。</p>
<ul>
<li>lxc 是 Linux上老牌的容器 runtime. Docker 最初也是用 lxc 作为 runtime .</li>
<li>runc  是 Docker  自己开发的容器 runtime ，符合OC1  规范，也是现在 Docker 的默认runtune .</li>
<li>rkt  是 Core08 开发的容器 runtime ，符合OCI  规范，因而能够运行 Docker 的容器。</li>
</ul>
<h4 id="容器管理工具"><a href="#容器管理工具" class="headerlink" title="容器管理工具"></a>容器管理工具</h4><p>光有 runtJme 还不够，用户得有工具来管理容器。容器管理工具对内与 runtlme 交互， 对外为用户提供 interface ，比如CLI 。</p>
<ul>
<li><code>lxd</code> 是 lxc 对应的管理工具 。</li>
<li>runc 的管理工具是 <code>docker engine</code>。 docker engine 包含后台 deamon 和 cli 两个部分。我们 通常提到 Docker。 一般就是指的 docker engine。</li>
<li>rkt 的管理工具是 <code>rkt cli</code>.</li>
</ul>
<h4 id="容器定义工具"><a href="#容器定义工具" class="headerlink" title="容器定义工具"></a>容器定义工具</h4><p>容器定义工具 容器定义工具允许用户定义容器的内容和属性，这样容器就能够被保存、共享和重建。</p>
<ul>
<li><code>docker image</code> 是 Docker 容器的模板. runtime 依据 docker image 创建容器。</li>
<li><code>dockerfile</code> 是包含若干命令的文本文件，可以通过这些命令创建出 docker image .</li>
<li><code>ACI (App Container Image)</code>  与 docker image 类似，只不过它是由 CoreOS  开发的出容器 的 image格式 。</li>
</ul>
<h4 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h4><p>容器是通过 image  创建的，需要有一个仓库来统 一存放 lmage ，这个仓库就叫做Registry 。</p>
<ul>
<li>企业可以用 Docker Registry 构建私有的 Registry 。</li>
<li>Docker  Hub  ( <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a>)   是 Docker  为公众提供的托管 Registry，上面有很多现成的 image。为 Docker 用户提供了极大的便利 。</li>
<li>Quay.io  (<a target="_blank" rel="noopener" href="https://quay.io/">https://quay.io/</a>)  是另一个公共托管Registry，提供与 DockerHub 类似的服务。</li>
</ul>
<h4 id="容器OS"><a href="#容器OS" class="headerlink" title="容器OS"></a>容器OS</h4><p>由于有容器 runtime ，几乎所有的linux、 MAC  OS 和 Windows  都可以运行容器，但这并没有妨碍容器 OS 的问世。</p>
<p>容器 OS  是专门运行容器的操作系统。与常规OS 相比，容器OS  通常体积更小，启动更快。因为是为容器定制的 OS. 通常它们运行容器的效率会更高。</p>
<h3 id="容器平台技术"><a href="#容器平台技术" class="headerlink" title="容器平台技术"></a>容器平台技术</h3><p>容器核心技术使得容器能够在单个 host 上运行，==而容器平台技术能够让容器作为集群在分布式环境中运行== 。</p>
<p><img src="https://i.loli.net/2021/01/24/5C71FA3VTxHOK8c.png"></p>
<h4 id="容器编排引擎"><a href="#容器编排引擎" class="headerlink" title="容器编排引擎"></a>容器编排引擎</h4><p>基于容器的应用一般会采用微服务架构。在这种架构下，应用被划分为不同的组件，并以 服务的形式运行在各自的容器中，通过 API  对外提供服务。为了保证应用的高可用，每个组件 都可能会运行多个相同的容器。这些容器会组成集群，集群中的容器会根据业务需要被动态地 创建、迁移和销毁。</p>
<p>这样一个基于微服务架构的应用系统实际上是 一个动态的可伸缩的系统。 这对我们的部署环境提出了新的要求，我们需要有一种高效的方法来==管理容器集群==。而这，就是容器编排引擎要干的工作。</p>
<p>所谓编排 (orchestration )  。通常包括容器管理、调度、集群定义和服务发现等。通过容器 编排引擎，容器被有机地组合成微服务应用，实现业务需求。</p>
<ul>
<li>docker swarm 是 Docker 开发的容器编排引擎 。</li>
<li>kubernetes  是 Google  领导开发的开源容器编排引擎，同时支持 Docker  和 CoreOS容器 。</li>
<li>mesos是一个通用的集群资源调度平台， mesos 与 marathon 一起提供容器编排引擎功能。 </li>
</ul>
<h4 id="容器管理平台"><a href="#容器管理平台" class="headerlink" title="容器管理平台"></a>容器管理平台</h4><p>容器管理平台是架构在容器编排引擎之上的 一个更为通用的平台。通常容器管理平台能够 支持多种编排引擎，抽象了编排引擎的底层实现细节，为用户提供更方便的功能 ，比如 application catalog  和一键应用部署等。</p>
<p>Rancher 和 ContainerShip 是容器管理平台的典型代表。</p>
<h4 id="基于容器的PaaS"><a href="#基于容器的PaaS" class="headerlink" title="基于容器的PaaS"></a>基于容器的PaaS</h4><p>基于容器的 PaaS  为微服务应用开发人员和公司提供了开发、部署和管理应用的平台 ，使用户不必关心底层基础设施而专注于应用的开发。</p>
<h3 id="容器支持技术"><a href="#容器支持技术" class="headerlink" title="容器支持技术"></a>容器支持技术</h3><p>用于支持基于容器的基础设施相干技术。</p>
<p><img src="https://i.loli.net/2021/01/24/KhIaGTOR26LHC7b.png" alt="image.png"></p>
<h4 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h4><p>容器的出现使网络拓扑变得更加动态和复杂。用户需要专门的解决方案来管理容器与容器、容器与其他实体之间的连通性和隔离性。</p>
<ul>
<li>docker network 是 Docker 原生的网络解决方案。</li>
<li>除此之外，我们还可以采用第三方开源解决方案，例如 flanne1、weave 和 calico。不同方案的设计和实现方式不同，各有优势和特点， 应根据实际需要来选型。</li>
</ul>
<h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><p>动态变化是微服务应用的一大特点。当负载增加时，集群会自动创建新的容器:负载减小，多余的容器会被销毁。容器也会根据 host 的资源使用情况在不同 host 中迁移，容器的IP和端口也会随之发生变化。</p>
<p>在这种动态的环镜下，必须要有一种机制让 client  能够知道如何访问容器提供的服务。这就是服务发现技术要完成的工作。</p>
<p>服务发现会保存容器集群中所有微服务最新的信息，比如 IP 和端口，并对外提供 API。提供服务查询功能。</p>
<p>etcd 、consu1  和 zookeeper  是服务发现的典型解决方案。</p>
<h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h4><p>监控对于基础架构非常重要，而容器的动态特征对监控提出更多挑战。针对容器环境，已经涌现出很多监控工具和方案</p>
<p>docker ps/top/stats是 Docker  原生的命令行监控工具。除了命令行， Docker 也提供了stats API ，用户可以通过HTIP 请求获取容器的状态信息。</p>
<p>sysdig、 cAdvisor/Heapster 和 WeaveScope 是其他开源的容器监控方案。</p>
<h4 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h4><p>容器经常会在不同的 host  之间迁移，如何保证持久化数据也能够动态迁移，是 Rex-Ray这类数据管理工具提供的能力</p>
<h4 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h4><p>日志为问题排查和事件管理提供了重要依据。日志工具有两类：</p>
<ul>
<li>docker logs 是 Docker 原生的日志工具。</li>
<li>而 logspout 对日志提供了路由功能，它可以收集不同容器的日志并转发给其他工具进行后处理 。</li>
</ul>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>对于年轻的容器，安全性 一直是业界争论的焦点。  OpenSCAP 是一种容器安全工具。OpenSCAP  能够对容器镜像进行扫描，发现潜在的漏洞。</p>
<h2 id="Docker-核心知识"><a href="#Docker-核心知识" class="headerlink" title="Docker 核心知识"></a>Docker 核心知识</h2><h3 id="what—什么是容器"><a href="#what—什么是容器" class="headerlink" title="what—什么是容器"></a>what—什么是容器</h3><p>Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Docker_(software)">2013 年 3 月以 Apache 2.0 授权协议开源</a>，主要项目代码在 <a target="_blank" rel="noopener" href="https://github.com/moby/moby">GitHub</a> 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 <a target="_blank" rel="noopener" href="https://www.opencontainers.org/">开放容器联盟（OCI）</a>。</p>
<p>Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目已经超过 4 万 6 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，<a target="_blank" rel="noopener" href="https://blog.docker.com/2013/10/dotcloud-is-becoming-docker-inc/">dotCloud 公司决定改名为 Docker</a>。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。</p>
<p>Docker 使用 Google 公司推出的 <a target="_blank" rel="noopener" href="https://golang.org/">Go 语言</a> 进行开发实现，基于 Linux 内核的 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Cgroups">cgroup</a>，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Linux_namespaces">namespace</a>，以及 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Aufs">AUFS</a> 类的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 等技术，对进程进行封装隔离，属于 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 <a target="_blank" rel="noopener" href="https://linuxcontainers.org/lxc/introduction/">LXC</a>，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 <a target="_blank" rel="noopener" href="https://github.com/docker/libcontainer">libcontainer</a>，从 1.11 开始，则进一步演进为使用 <a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc">runC</a> 和 <a target="_blank" rel="noopener" href="https://github.com/containerd/containerd">containerd</a>。</p>
<p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p>
<h4 id="容器与虚拟机"><a href="#容器与虚拟机" class="headerlink" title="容器与虚拟机"></a>容器与虚拟机</h4><p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
<p><img src="https://i.loli.net/2021/01/24/drcyhKolWp2ZetI.png"></p>
<p><img src="https://i.loli.net/2021/01/24/bEaWjAtvfSTCHF4.png"></p>
<h3 id="why—为什么需要容器"><a href="#why—为什么需要容器" class="headerlink" title="why—为什么需要容器"></a>why—为什么需要容器</h3><h4 id="容器解决的问题"><a href="#容器解决的问题" class="headerlink" title="容器解决的问题"></a>容器解决的问题</h4><p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势</p>
<h5 id="更高效的利用系统资源"><a href="#更高效的利用系统资源" class="headerlink" title="更高效的利用系统资源"></a>更高效的利用系统资源</h5><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p>
<h5 id="更快速的启动时间"><a href="#更快速的启动时间" class="headerlink" title="更快速的启动时间"></a>更快速的启动时间</h5><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p>
<h5 id="一致的运行环境"><a href="#一致的运行环境" class="headerlink" title="一致的运行环境"></a>一致的运行环境</h5><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 <em>「这段代码在我机器上没问题啊」</em> 这类问题。</p>
<h5 id="持续交付和部署"><a href="#持续交付和部署" class="headerlink" title="持续交付和部署"></a>持续交付和部署</h5><p>对开发和运维（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/DevOps">DevOps</a>）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p>
<p>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 <code>Dockerfile</code> 来进行镜像构建，并结合 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Continuous_integration">持续集成(Continuous Integration)</a> 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Continuous_delivery">持续部署(Continuous Delivery/Deployment)</a> 系统进行自动部署。</p>
<p>而且使用 <code>Dockerfile</code> 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像</p>
<h5 id="更轻松的迁移"><a href="#更轻松的迁移" class="headerlink" title="更轻松的迁移"></a>更轻松的迁移</h5><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p>
<h5 id="更轻松的维护和扩展"><a href="#更轻松的维护和扩展" class="headerlink" title="更轻松的维护和扩展"></a>更轻松的维护和扩展</h5><p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 <a target="_blank" rel="noopener" href="https://store.docker.com/search?q=&source=verified&type=image">官方镜像</a>，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本</p>
<h3 id="How-—容器时如何工作的"><a href="#How-—容器时如何工作的" class="headerlink" title="How —容器时如何工作的"></a>How —容器时如何工作的</h3><h4 id="Docker-engine"><a href="#Docker-engine" class="headerlink" title="Docker engine"></a>Docker engine</h4><p>Docker 引擎是一个包含以下主要组件的客户端服务器应用程序。</p>
<ul>
<li>一种服务器，它是一种称为守护进程并且长时间运行的程序。</li>
<li>REST API用于指定程序可以用来与守护进程通信的接口，并指示它做什么。</li>
<li>一个有命令行界面 (CLI) 工具的客户端。</li>
</ul>
<p>Docker 引擎组件的流程如下图所示：</p>
<p><img src="https://i.loli.net/2021/01/24/xMI6y4chiYqtNG5.png" alt="image.png"></p>
<h4 id="Docker-系统架构"><a href="#Docker-系统架构" class="headerlink" title="Docker 系统架构"></a>Docker 系统架构</h4><p>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程 API 来管理和创建 Docker 容器。</p>
<p>Docker 容器通过 Docker 镜像来创建。</p>
<p>容器与镜像的关系类似于面向对象编程中的对象与类。</p>
<table>
<thead>
<tr>
<th align="left">Docker</th>
<th align="left">面向对象</th>
</tr>
</thead>
<tbody><tr>
<td align="left">容器</td>
<td align="left">对象</td>
</tr>
<tr>
<td align="left">镜像</td>
<td align="left">类</td>
</tr>
</tbody></table>
<p><img src="https://i.loli.net/2021/01/24/wPmJEKRWnB1fM37.png" alt="image.png"></p>
<table>
<thead>
<tr>
<th align="left">标题</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">镜像(Images)</td>
<td align="left">Docker 镜像是用于创建 Docker 容器的模板。</td>
</tr>
<tr>
<td align="left">容器(Container)</td>
<td align="left">容器是独立运行的一个或一组应用。</td>
</tr>
<tr>
<td align="left">客户端(Client)</td>
<td align="left">Docker 客户端通过命令行或者其他工具使用 Docker API (<a target="_blank" rel="noopener" href="https://docs.docker.com/reference/api/docker_remote_api">https://docs.docker.com/reference/api/docker_remote_api</a>) 与 Docker 的守护进程通信。</td>
</tr>
<tr>
<td align="left">Docker daemon</td>
<td align="left">服务器组件，以Linux后台服务的方式运行，Docker daemon运行在Docker host上，负责创建、运行、监控容器，构建、存储镜像。<br/>默认配置下Docker daemon只能响应本地Host的客户端请求。</td>
</tr>
<tr>
<td align="left">主机(Host)</td>
<td align="left">一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td>
</tr>
<tr>
<td align="left">仓库(Registry)</td>
<td align="left">Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(<a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。</td>
</tr>
<tr>
<td align="left">Docker Machine</td>
<td align="left">Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</td>
</tr>
</tbody></table>
<h2 id="Docker-Image"><a href="#Docker-Image" class="headerlink" title="Docker Image"></a>Docker Image</h2><h3 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h3><p>操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:16.04</code> 就包含了完整的一套 Ubuntu 16.04 最小系统的 <code>root</code> 文件系统。</p>
<p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变</p>
<p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p>
<p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure>

<p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，这里我们说一下镜像名称的格式。</p>
<ul>
<li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub。</li>
<li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li>
</ul>
<p>比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker pull ubuntu:16.04</span></span><br><span class="line">16.04: Pulling from library/ubuntu</span><br><span class="line">bf5d46315322: Pull complete</span><br><span class="line">9f13e0ac480c: Pull complete</span><br><span class="line">e8988b5b3097: Pull complete</span><br><span class="line">40af181810e7: Pull complete</span><br><span class="line">e6f7c7e5c03e: Pull complete</span><br><span class="line">Digest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe</span><br><span class="line">Status: Downloaded newer image for ubuntu:16.04</span><br></pre></td></tr></table></figure>

<p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 <code>ubuntu:16.04</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>16.04</code> 的镜像。</p>
<p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 <code>sha256</code> 的摘要，以确保下载一致性。</p>
<p>在使用上面命令的时候，你可能会发现，你所看到的层 ID 以及 <code>sha256</code> 的摘要和这里的不一样。这是因为官方镜像是一直在维护的，有任何新的 bug，或者版本更新，都会进行修复再以原来的标签发布，这样可以确保任何使用这个标签的用户可以获得更安全、更稳定的镜像。</p>
<p><em>如果从 Docker Hub 下载镜像非常缓慢，可以参照 <code>镜像加速器</code> 一节配置加速器。</em></p>
<h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">docker image ls </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos ~]# docker images</span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu-with-vim      latest              08d108b45e78        23 hours ago        514MB</span><br><span class="line">ubuntu-with-vi       latest              126c81439955        24 hours ago        131MB</span><br><span class="line">ubuntu               16.04               9499db781771        2 months ago        131MB</span><br><span class="line">ubuntu               latest              f643c72bc252        2 months ago        72.9MB</span><br><span class="line">postgres             9.5                 693ab34b0689        2 months ago        197MB</span><br><span class="line">mysql                5.7                 c791733bf9b7        2 months ago        449MB</span><br><span class="line">hello-world          latest              bf756fb1ae65        13 months ago       13.3kB</span><br><span class="line">jaspeen/oracle-11g   latest              0c8711fe4f0f        5 years ago         281MB</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos ~]# docker image ls </span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu-with-vim      latest              08d108b45e78        23 hours ago        514MB</span><br><span class="line">ubuntu-with-vi       latest              126c81439955        24 hours ago        131MB</span><br><span class="line">ubuntu               16.04               9499db781771        2 months ago        131MB</span><br><span class="line">ubuntu               latest              f643c72bc252        2 months ago        72.9MB</span><br><span class="line">postgres             9.5                 693ab34b0689        2 months ago        197MB</span><br><span class="line">mysql                5.7                 c791733bf9b7        2 months ago        449MB</span><br><span class="line">hello-world          latest              bf756fb1ae65        13 months ago       13.3kB</span><br><span class="line">jaspeen/oracle-11g   latest              0c8711fe4f0f        5 years ago         281MB</span><br></pre></td></tr></table></figure>

<h4 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h4><p>为了加速镜像构建、重复利用资源，Docker 会利用 <strong>中间层镜像</strong>。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 <code>docker image ls</code> 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 <code>-a</code> 参数。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls -a </span><br></pre></td></tr></table></figure>



<h4 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h4><p><code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。以下命令来便捷的查看镜像、容器、数据卷所占用的空间。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system df </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos ~]# docker system df </span><br><span class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</span><br><span class="line">Images              8                   6                   1.514GB             609MB (40%)</span><br><span class="line">Containers          7                   0                   383.7MB             383.7MB (100%)</span><br><span class="line">Local Volumes       1                   1                   207.2MB             0B (0%)</span><br><span class="line">Build Cache         0                   0                   0B                  0B</span><br></pre></td></tr></table></figure>



<h4 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h4><p>根据仓库名列出镜像，可以自动补齐（Tab键）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls ubuntu</span><br></pre></td></tr></table></figure>

<p>列出特定的某个镜像，也就是说指定仓库名和标签，可以自动补齐（Tab键）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">docker image ls ubuntu:16.04</span><br></pre></td></tr></table></figure>

<p>除此以外，<code>docker image ls</code> 还支持强大的过滤器参数 <code>--filter</code>，或者简写 <code>-f</code></p>
<h4 id="以特定格式显示"><a href="#以特定格式显示" class="headerlink" title="以特定格式显示"></a>以特定格式显示</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos ~]# docker image ls -q</span><br><span class="line">08d108b45e78</span><br><span class="line">126c81439955</span><br><span class="line">9499db781771</span><br><span class="line">f643c72bc252</span><br><span class="line">693ab34b0689</span><br><span class="line">c791733bf9b7</span><br><span class="line">bf756fb1ae65</span><br><span class="line">0c8711fe4f0f</span><br></pre></td></tr></table></figure>

<p>==GO语法模板==</p>
<p>只包含镜像ID和仓库名</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">oot@VM-0-11-centos ~]# docker image ls --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</span><br><span class="line">08d108b45e78: ubuntu-with-vim</span><br><span class="line">126c81439955: ubuntu-with-vi</span><br><span class="line">9499db781771: ubuntu</span><br><span class="line">f643c72bc252: ubuntu</span><br><span class="line">693ab34b0689: postgres</span><br><span class="line">c791733bf9b7: mysql</span><br><span class="line">bf756fb1ae65: hello-world</span><br><span class="line">0c8711fe4f0f: jaspeen/oracle-11g</span><br><span class="line">[root@VM-0-11-centos ~]# </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos ~]# docker image ls --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;&quot;</span><br><span class="line">IMAGE ID            REPOSITORY           TAG</span><br><span class="line">08d108b45e78        ubuntu-with-vim      latest</span><br><span class="line">126c81439955        ubuntu-with-vi       latest</span><br><span class="line">9499db781771        ubuntu               16.04</span><br><span class="line">f643c72bc252        ubuntu               latest</span><br><span class="line">693ab34b0689        postgres             9.5</span><br><span class="line">c791733bf9b7        mysql                5.7</span><br><span class="line">bf756fb1ae65        hello-world          latest</span><br><span class="line">0c8711fe4f0f        jaspeen/oracle-11g   latest</span><br></pre></td></tr></table></figure>

<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><h4 id="基础命令-1"><a href="#基础命令-1" class="headerlink" title="基础命令"></a>基础命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p>
<p>可以使用 <code>docker image ls -q</code> 来配合使用 <code>docker image rm</code>，这样可以成批的删除希望删除的镜像。</p>
<p>比如，需要删除所有仓库名为 <code>redis</code> 的镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm $(docker image ls -q redis)</span><br></pre></td></tr></table></figure>



<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><h4 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h4><p>步骤：</p>
<ol>
<li>运行容器</li>
<li>修改容器</li>
<li>将容器报存为新的镜像</li>
</ol>
<h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><p>Dockerfile 是一个文本文件，其内包含了一条条的**指令(Instruction)**，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<h5 id="第一个Demo"><a href="#第一个Demo" class="headerlink" title="第一个Demo"></a>第一个Demo</h5><ul>
<li>在空白目录下新建目录，并创建 Dockerfile文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos data]# mkdir mynginx</span><br><span class="line">[root@VM-0-11-centos data]# cd mynginx/</span><br><span class="line">[root@VM-0-11-centos mynginx]# touch Dockerfile</span><br></pre></td></tr></table></figure>

<ul>
<li>Dockerfile内容为：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>

<ul>
<li>执行docker build命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos mynginx]# docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/2 : FROM nginx</span><br><span class="line">latest: Pulling from library/nginx</span><br><span class="line">a076a628af6f: Pull complete </span><br><span class="line">0732ab25fa22: Pull complete </span><br><span class="line">d7f36f6fe38f: Pull complete </span><br><span class="line">f72584a26f32: Pull complete </span><br><span class="line">7125e4df9063: Pull complete </span><br><span class="line">Digest: sha256:10b8cc432d56da8b61b070f4c7d2543a9ed17c2b23010b43af434fd40e2ca4aa</span><br><span class="line">Status: Downloaded newer image for nginx:latest</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> f6d0b4767a6c</span></span><br><span class="line">Step 2/2 : RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 2ddb4b16e777</span></span><br><span class="line">Removing intermediate container 2ddb4b16e777</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> d8429783e126</span></span><br><span class="line">Successfully built d8429783e126</span><br><span class="line">Successfully tagged nginx:v3</span><br></pre></td></tr></table></figure>

<p><code>. </code>指定build context为当前目录，Docker 默认会从build context中查找Dockerfile文件，可以通过-f 参数指定Dockerfile的位置。这是在指定<strong>上下文路径</strong>。</p>
<p>当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<p>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p>
<p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p>
<p>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p>
<blockquote>
<p>总结：</p>
</blockquote>
<ol>
<li>从base镜像运行一个容器</li>
<li>执行一条命令，对容器进行修改</li>
<li>执行类型docker commit的操作，生成一个新的镜像层</li>
<li>Docker 再基于刚刚的镜像运行一个新容器</li>
<li>重复2-4步，直到Dockerfile中的所有指令执行完毕</li>
</ol>
<h5 id="查看镜像分层"><a href="#查看镜像分层" class="headerlink" title="查看镜像分层"></a>查看镜像分层</h5><p>docker history 会显示镜像的构建历史，也就是Dockerfile的执行过程。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker histroy</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos /]# docker history nginx:v3 </span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE        COMMENT</span><br><span class="line">d8429783e126        13 minutes ago      /bin/sh -c echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; …   24B     </span><br><span class="line">f6d0b4767a6c        2 weeks ago         /bin/sh -c #(nop)  CMD [&quot;nginx&quot; &quot;-g&quot; &quot;daemon…   0B     </span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop)  STOPSIGNAL SIGQUIT           0B     </span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop)  EXPOSE 80                    0B     </span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop)  ENTRYPOINT [&quot;/docker-entr…   0B     </span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop) COPY file:0fd5fca330dcd6a7…   1.04kB </span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop) COPY file:0b866ff3fc1ef5b0…   1.96kB </span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop) COPY file:e7e183879c35719c…   1.2kB   </span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c set -x     &amp;&amp; addgroup --system -…   63.7MB  &lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop)  ENV PKG_RELEASE=1~buster     0B</span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop)  ENV NJS_VERSION=0.5.0        0B     </span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop)  ENV NGINX_VERSION=1.19.6     0B     </span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop)  LABEL maintainer=NGINX Do…   0B     </span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop)  CMD [&quot;bash&quot;]                 0B     </span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop) ADD file:422aca8901ae3d869…   69.2MB </span><br></pre></td></tr></table></figure>

<p>注：missing表示无法获取IMAGE ID，通常从Docker Hub下载的镜像会有这个问题</p>
<h5 id="其它-docker-build-的用法"><a href="#其它-docker-build-的用法" class="headerlink" title="其它 docker build 的用法"></a>其它 <code>docker build</code> 的用法</h5><h6 id="直接用-Git-repo-进行构建"><a href="#直接用-Git-repo-进行构建" class="headerlink" title="直接用 Git repo 进行构建"></a>直接用 Git repo 进行构建</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build https://github.com/twang2218/gitlab-ce-zh.git</span><br></pre></td></tr></table></figure>



<h6 id="用给定的-tar-压缩包构建"><a href="#用给定的-tar-压缩包构建" class="headerlink" title="用给定的 tar 压缩包构建"></a>用给定的 tar 压缩包构建</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build http://server/context.tar.gz</span><br></pre></td></tr></table></figure>

<h4 id="Dockerfile常用指令"><a href="#Dockerfile常用指令" class="headerlink" title="Dockerfile常用指令"></a>Dockerfile常用指令</h4><h5 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h5><p>指定base镜像</p>
<h5 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h5><p>设置镜像作者</p>
<h5 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h5><p>将文件从build context 复制到镜像</p>
<p><code>COPY</code>支持两种形式：COPY  src dest 与 COPY[“src”, “desc”]。</p>
<p>注意：src只能指定build context中的文件或目录</p>
<p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY package.json /usr/src/app/</span><br></pre></td></tr></table></figure>

<p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<h5 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h5><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</p>
<p>从build context复制文件到镜像，如果src是归档文件（tar、zip、tgz、xz等），文件会被自动解约到dest。</p>
<p>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 <code>ADD</code> 命令了。</p>
<p>在 Docker 官方的 <code>Dockerfile 最佳实践文档</code> 中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</p>
<p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code></p>
<h5 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h5><p>设置环境变量。</p>
<p>格式有两种：</p>
<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li>
</ul>
<p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 <code>node</code> 镜像 <code>Dockerfile</code> 中，就有类似这样的代码：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> NODE_VERSION <span class="number">7.2</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span></span><br><span class="line"><span class="bash">  &amp;&amp; curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span> \</span></span><br><span class="line"><span class="bash">  &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \</span></span><br><span class="line"><span class="bash">  &amp;&amp; grep <span class="string">&quot; node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz\$&quot;</span> SHASUMS256.txt | sha256sum -c - \</span></span><br><span class="line"><span class="bash">  &amp;&amp; tar -xJf <span class="string">&quot;node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> -C /usr/<span class="built_in">local</span> --strip-components=1 \</span></span><br><span class="line"><span class="bash">  &amp;&amp; rm <span class="string">&quot;node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> SHASUMS256.txt.asc SHASUMS256.txt \</span></span><br><span class="line"><span class="bash">  &amp;&amp; ln -s /usr/<span class="built_in">local</span>/bin/node /usr/<span class="built_in">local</span>/bin/nodejs</span></span><br></pre></td></tr></table></figure>

<p>在这里先定义了环境变量 <code>NODE_VERSION</code>，其后的 <code>RUN</code> 这层里，多次使用 <code>$NODE_VERSION</code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 <code>7.2.0</code> 即可，<code>Dockerfile</code> 构建维护变得更轻松了。</p>
<p>下列指令可以支持环境变量展开： <code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code>。</p>
<p>可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 <code>Dockerfile</code> 制作更多的镜像，只需使用不同的环境变量即可</p>
<h5 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h5><p>指定容器中的进程会监听某个端口，Docker可以将该端口暴露出去。</p>
<p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p>
<p><code>EXPOSE</code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p>
<p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
<h5 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h5><p>将文件或者目录声明为volume。</p>
<p>格式为：</p>
<ul>
<li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li>
<li><code>VOLUME &lt;路径&gt;</code></li>
</ul>
<h5 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h5><p>为后面的RUN、CMD、ENTRY、ADD或COPY指令设置镜像中的当前工作目录。</p>
<p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p>
<p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p>
<p>之前提到一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; world.txt</span></span><br></pre></td></tr></table></figure>

<p>如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 <code>Dockerfile</code> 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 <code>Dockerfile</code> 构建分层存储的概念不了解所导致的错误。</p>
<p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p>
<p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令</p>
<h5 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h5><p>在容器中运行指定的命令</p>
<p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p>
<ul>
<li><p><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure></li>
<li><p><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</p>
</li>
</ul>
<h5 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h5><p>容器启动时运行指定的命令。</p>
<p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p>
<ul>
<li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li>
<li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li>
<li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li>
</ul>
<p>Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。</p>
<p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p>
<p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>&quot;</code>，而不要使用单引号。</p>
<p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$HOME</span></span></span><br></pre></td></tr></table></figure>

<p>在实际执行中，会将其变更为：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo <span class="variable">$HOME</span>&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<h5 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h5><p>设置容器启动时运行的命令。</p>
<p>Dockerfile中可以有多个ENTRYPOINT指令，但只有最后一个生效。CMD或docker run 之后的参数会被当作参数传递给ENTRYPOINT。</p>
<p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。</p>
<p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。</p>
<p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; <span class="string">&quot;&lt;CMD&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>那么有了 <code>CMD</code> 后，为什么还要有 <code>ENTRYPOINT</code> 呢？这种 <code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code> 有什么好处么？让我们来看几个场景。</p>
<h6 id="场景一：让镜像变成像命令一样使用"><a href="#场景一：让镜像变成像命令一样使用" class="headerlink" title="场景一：让镜像变成像命令一样使用"></a>场景一：让镜像变成像命令一样使用</h6><p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 <code>CMD</code> 来实现：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install -y curl \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://ip.cn&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<p>假如我们使用 <code>docker build -t myip .</code> 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip</span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br></pre></td></tr></table></figure>

<p>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 <code>CMD</code> 中可以看到实质的命令是 <code>curl</code>，那么如果我们希望显示 HTTP 头信息，就需要加上 <code>-i</code> 参数。那么我们可以直接加 <code>-i</code> 参数给 <code>docker run myip</code> 么？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip -i</span><br><span class="line">docker: Error response from daemon: invalid header field value <span class="string">&quot;oci runtime error: container_linux.go:247: starting container process caused \&quot;exec: \\\&quot;-i\\\&quot;: executable file not found in <span class="variable">$PATH</span>\&quot;\n&quot;</span>.</span><br></pre></td></tr></table></figure>

<p>我们可以看到可执行文件找不到的报错，<code>executable file not found</code>。之前我们说过，跟在镜像名后面的是 <code>command</code>，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了原来的 <code>CMD</code>，而不是添加在原来的 <code>curl -s http://ip.cn</code> 后面。而 <code>-i</code> 根本不是命令，所以自然找不到。</p>
<p>那么如果我们希望加入 <code>-i</code> 这参数，我们就必须重新完整的输入这个命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip curl -s http://ip.cn -i</span><br></pre></td></tr></table></figure>

<p>这显然不是很好的解决方案，而使用 <code>ENTRYPOINT</code> 就可以解决这个问题。现在我们重新用 <code>ENTRYPOINT</code> 来实现这个镜像：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install -y curl \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://ip.cn&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<p>这次我们再来尝试直接使用 <code>docker run myip -i</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip</span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br><span class="line"></span><br><span class="line">$ docker run myip -i</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.8.0</span><br><span class="line">Date: Tue, 22 Nov 2016 05:12:40 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Powered-By: PHP/5.6.24-1~dotdeb+7.1</span><br><span class="line">X-Cache: MISS from cache-2</span><br><span class="line">X-Cache-Lookup: MISS from cache-2:80</span><br><span class="line">X-Cache: MISS from proxy-2_6</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Via: 1.1 cache-2:80, 1.1 proxy-2_6:8006</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br></pre></td></tr></table></figure>

<p>可以看到，这次成功了。这是因为当存在 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的内容将会作为参数传给 <code>ENTRYPOINT</code>，而这里 <code>-i</code> 就是新的 <code>CMD</code>，因此会作为参数传给 <code>curl</code>，从而达到了我们预期的效果。</p>
<h2 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h2><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>stopped</code>）的容器重新启动。</p>
<p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p>
<h4 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h4><p>所需要的命令主要为 <code>docker run</code>。</p>
<p>在讨论Dockerfile时，可用三种方式指定容器启动时执行的命令：</p>
<ul>
<li>CMD</li>
<li>ENTRYPOINT</li>
<li>docker run命令行中指定</li>
</ul>
<p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run ubuntu:14.04 /bin/<span class="built_in">echo</span> <span class="string">&#x27;Hello world&#x27;</span></span><br></pre></td></tr></table></figure>

<p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i ubuntu:14.04 /bin/bash</span><br><span class="line">root@af8bae53bdd3:/<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p>
<p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<h4 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h4><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止的容器启动运行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container start</span><br></pre></td></tr></table></figure>

<h3 id="守护态运行"><a href="#守护态运行" class="headerlink" title="守护态运行"></a>守护态运行</h3><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p>
<p>下面举两个例子来说明一下。</p>
<p>如果不使用 <code>-d</code> 参数运行容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos myip]<span class="comment"># docker run ubuntu:16.04  /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p>
<p>如果使用了 <code>-d</code> 参数运行容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos myip]<span class="comment"># docker run -d ubuntu:16.04  /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;  </span></span><br><span class="line">5173b19b14c49aa98c83f11466e56311411e61f21d3db798afe4095efef61f3a</span><br></pre></td></tr></table></figure>

<p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker logs</code> 查看)。</p>
<p><strong>注：</strong> 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p>
<p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p>
<p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos myip]<span class="comment"># docker container ls </span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                  NAMES</span><br><span class="line">5173b19b14c4        ubuntu:16.04        <span class="string">&quot;/bin/sh -c &#x27;while t…&quot;</span>   About a minute ago   Up About a minute                          sharp_bohr</span><br><span class="line">99a009bbe1f8        nginx               <span class="string">&quot;/docker-entrypoint.…&quot;</span>   8 hours ago          Up 8 hours          0.0.0.0:8080-&gt;80/tcp   nginx-demo</span><br></pre></td></tr></table></figure>

<p>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos myip]<span class="comment"># docker container logs 5173b19b14c4</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器。</p>
<p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p>
<p>例如对于上一章节中只启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p>
<p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -a</span><br></pre></td></tr></table></figure>

<p>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。</p>
<p>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p>
<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p>
<p>某些时候需要进入容器进行操作，包括使用 </p>
<p><code>docker attach</code> </p>
<p> <code>docker exec</code></p>
<h4 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a><code>attach</code> 命令</h4><p><code>docker attach</code> 是 Docker 自带的命令。下面示例如何使用该命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看运行中的容器</span></span><br><span class="line">[root@VM-0-11-centos myip]<span class="comment"># docker container ls </span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES</span><br><span class="line">5173b19b14c4        ubuntu:16.04        <span class="string">&quot;/bin/sh -c &#x27;while t…&quot;</span>   10 minutes ago      Up 10 minutes                              sharp_bohr</span><br><span class="line">99a009bbe1f8        nginx               <span class="string">&quot;/docker-entrypoint.…&quot;</span>   8 hours ago         Up 8 hours          0.0.0.0:8080-&gt;80/tcp   nginx-demo</span><br><span class="line"><span class="comment"># 进入该容器</span></span><br><span class="line">[root@VM-0-11-centos myip]<span class="comment"># docker attach 517</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line"><span class="comment"># 退出后查看运行中的容器</span></span><br><span class="line">[root@VM-0-11-centos myip]<span class="comment"># docker container ls </span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES</span><br><span class="line">99a009bbe1f8        nginx               <span class="string">&quot;/docker-entrypoint.…&quot;</span>   8 hours ago         Up 8 hours          0.0.0.0:8080-&gt;80/tcp   nginx-demo</span><br><span class="line">[root@VM-0-11-centos myip]<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<p>如果从这个 stdin 中 exit，会导致容器的停止</p>
<h4 id="exec-命令"><a href="#exec-命令" class="headerlink" title="exec 命令"></a><code>exec</code> 命令</h4><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p>
<p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p>
<p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos myip]<span class="comment"># docker exec -it 99a009bbe1f8 bash</span></span><br><span class="line">root@99a009bbe1f8:/<span class="comment"># ls -al</span></span><br><span class="line">total 88</span><br><span class="line">drwxr-xr-x  1 root root 4096 Jan 30 01:39 .</span><br><span class="line">drwxr-xr-x  1 root root 4096 Jan 30 01:39 ..</span><br><span class="line">-rwxr-xr-x  1 root root    0 Jan 30 01:39 .dockerenv</span><br><span class="line">drwxr-xr-x  2 root root 4096 Jan 11 00:00 bin</span><br><span class="line">drwxr-xr-x  2 root root 4096 Nov 22 12:37 boot</span><br><span class="line">drwxr-xr-x  5 root root  340 Jan 30 01:39 dev</span><br><span class="line">drwxr-xr-x  1 root root 4096 Jan 12 10:17 docker-entrypoint.d</span><br><span class="line">-rwxrwxr-x  1 root root 1202 Jan 12 10:16 docker-entrypoint.sh</span><br><span class="line">drwxr-xr-x  1 root root 4096 Jan 30 01:39 etc</span><br><span class="line">drwxr-xr-x  2 root root 4096 Nov 22 12:37 home</span><br><span class="line">drwxr-xr-x  1 root root 4096 Jan 12 10:17 lib</span><br><span class="line">drwxr-xr-x  2 root root 4096 Jan 11 00:00 lib64</span><br><span class="line">drwxr-xr-x  2 root root 4096 Jan 11 00:00 media</span><br><span class="line">drwxr-xr-x  2 root root 4096 Jan 11 00:00 mnt</span><br><span class="line">drwxr-xr-x  2 root root 4096 Jan 11 00:00 opt</span><br><span class="line">dr-xr-xr-x 93 root root    0 Jan 30 01:39 proc</span><br><span class="line">drwx------  2 root root 4096 Jan 11 00:00 root</span><br><span class="line">drwxr-xr-x  1 root root 4096 Jan 30 01:39 run</span><br><span class="line">drwxr-xr-x  2 root root 4096 Jan 11 00:00 sbin</span><br><span class="line">drwxr-xr-x  2 root root 4096 Jan 11 00:00 srv</span><br><span class="line">dr-xr-xr-x 13 root root    0 Jan 30 01:39 sys</span><br><span class="line">drwxrwxrwt  1 root root 4096 Jan 12 10:17 tmp</span><br><span class="line">drwxr-xr-x  1 root root 4096 Jan 11 00:00 usr</span><br><span class="line">drwxr-xr-x  1 root root 4096 Jan 11 00:00 var</span><br><span class="line">root@99a009bbe1f8:/<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 <code>docker exec</code> 的原因。</p>
<h2 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h2><p>仓库（<code>Repository</code>）是集中存放镜像的地方。</p>
<p>一个容易混淆的概念是注册服务器（<code>Registry</code>）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 <code>dl.dockerpool.com/ubuntu</code> 来说，<code>dl.dockerpool.com</code> 是注册服务器地址，<code>ubuntu</code> 是仓库名。</p>
<h3 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h3><p>目前 Docker 官方维护了一个公共仓库 <a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a>，其中已经包括了数量超过 15,000 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现</p>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>你可以在 <a target="_blank" rel="noopener" href="https://cloud.docker.com/">https://cloud.docker.com</a> 免费注册一个 Docker 账号</p>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>可以通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p>
<p>你可以通过 <code>docker logout</code> 退出登录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@VM-0-11-centos myip]<span class="comment"># docker login</span></span><br><span class="line">Login with your Docker ID to push and pull images from Docker Hub. If you don<span class="string">&#x27;t have a Docker ID, head over to https://hub.docker.com to create one.</span></span><br><span class="line"><span class="string">Username: kesenhuang</span></span><br><span class="line"><span class="string">Password: </span></span><br><span class="line"><span class="string">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span></span><br><span class="line"><span class="string">Configure a credential helper to remove this warning. See</span></span><br><span class="line"><span class="string">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Login Succeeded</span></span><br></pre></td></tr></table></figure>

<h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos myip]<span class="comment"># docker search centos</span></span><br><span class="line">NAME                                            DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">centos                                          The official build of CentOS.                   465       [OK]</span><br><span class="line">tianon/centos                                   CentOS 5 and 6, created using rinse instea...   28</span><br><span class="line">blalor/centos                                   Bare-bones base CentOS 6.5 image                6                    [OK]</span><br><span class="line">saltstack/centos-6-minimal                                                                      6                    [OK]</span><br><span class="line">tutum/centos-6.4                                DEPRECATED. Use tutum/centos:6.4 instead. ...   5                    [OK]</span><br></pre></td></tr></table></figure>

<p>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建、是否自动创建。</p>
<p>官方的镜像说明是官方项目组创建和维护的，automated 资源允许用户验证镜像的来源和内容。</p>
<p>根据是否是官方提供，可将镜像资源分为两类。</p>
<p>一种是类似 <code>centos</code> 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。</p>
<p>还有一种类型，比如 <code>tianon/centos</code> 镜像，它是由 Docker 的用户创建并维护的，往往带有用户名称前缀。可以通过前缀 <code>username/</code> 来指定使用某个用户提供的镜像，比如 tianon 用户。</p>
<p>另外，在查找的时候通过 <code>--filter=stars=N</code> 参数可以指定仅显示收藏数量为 <code>N</code> 以上的镜像。</p>
<h3 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h3><p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos myip]<span class="comment"># docker tag ubuntu:16.04  kesenhuang/ubuntu:16.04</span></span><br><span class="line">[root@VM-0-11-centos myip]<span class="comment"># docker push kesenhuang/ubuntu</span></span><br><span class="line">The push refers to repository [docker.io/kesenhuang/ubuntu]</span><br><span class="line">1a1a19626b20: Mounted from library/ubuntu </span><br><span class="line">5b7dc8292d9b: Mounted from library/ubuntu </span><br><span class="line">bbc674332e2e: Mounted from library/ubuntu </span><br><span class="line">da2785b7bb16: Mounted from library/ubuntu </span><br><span class="line">16.04: digest: sha256:85882f461cf3db2c743d8b17fdba79e522bc33af182f14bc7b6d45b6adb9adcf size: 1150</span><br></pre></td></tr></table></figure>

<h3 id="Docker-私有仓库"><a href="#Docker-私有仓库" class="headerlink" title="Docker 私有仓库"></a>Docker 私有仓库</h3><p>有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。</p>
<p>本节介绍如何使用本地仓库。</p>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/registry/"><code>docker-registry</code></a> 是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 <a target="_blank" rel="noopener" href="https://github.com/docker/distribution"><code>docker-registry</code></a> v2.x 版本。</p>
<h4 id="安装运行-docker-registry"><a href="#安装运行-docker-registry" class="headerlink" title="安装运行 docker-registry"></a>安装运行 docker-registry</h4><h4 id="容器运行"><a href="#容器运行" class="headerlink" title="容器运行"></a>容器运行</h4><p>你可以通过获取官方 <code>registry</code> 镜像来运行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --restart=always --name registry registry</span><br></pre></td></tr></table></figure>

<p>这将使用官方的 <code>registry</code> 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code> 目录下。你可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 <code>/opt/data/registry</code> 目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos ~]<span class="comment"># docker run -d \</span></span><br><span class="line">&gt;     -p 5000:5000 \</span><br><span class="line">&gt;     -v /opt/data/registry:/var/lib/registry \</span><br><span class="line">&gt;     registry</span><br></pre></td></tr></table></figure>

<h4 id="在私有仓库上传、搜索、下载镜像"><a href="#在私有仓库上传、搜索、下载镜像" class="headerlink" title="在私有仓库上传、搜索、下载镜像"></a>在私有仓库上传、搜索、下载镜像</h4><p>创建好私有仓库之后，就可以使用 <code>docker tag</code> 来标记一个镜像，然后推送它到仓库。例如私有仓库地址为 <code>127.0.0.1:5000</code>。</p>
<p>先在本机查看已有的镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure>

<p>使用 <code>docker tag</code> 将 <code>ubuntu:latest</code> 这个镜像标记为 <code>127.0.0.1:5000/ubuntu:latest</code>。</p>
<p>格式为 <code>docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos ~]<span class="comment"># docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:lates</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>docker push</code> 上传标记的镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos ~]<span class="comment"># docker push 127.0.0.1:5000/ubuntu:latest </span></span><br><span class="line">The push refers to repository [127.0.0.1:5000/ubuntu]</span><br><span class="line">f6253634dc78: Pushed </span><br><span class="line">9069f84dbbe9: Pushed </span><br><span class="line">bacd3af13903: Pushed </span><br><span class="line">latest: digest: sha256:4e4bc990609ed865e07afc8427c30ffdddca5153fd4e82c20d8f0783a291e241 size: 943</span><br></pre></td></tr></table></figure>

<p>用 <code>curl</code> 查看仓库中的镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos ~]<span class="comment"># curl 127.0.0.1:5000/v2/_catalog</span></span><br><span class="line">&#123;<span class="string">&quot;repositories&quot;</span>:[<span class="string">&quot;ubuntu&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到 <code>&#123;&quot;repositories&quot;:[&quot;ubuntu&quot;]&#125;</code>，表明镜像已经被成功上传了。</p>
<p>先删除已有镜像，再尝试从私有仓库中下载这个镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">myip                    latest              5046817304ae        24 hours ago        147MB</span><br><span class="line">nginx                   v3                  d8429783e126        25 hours ago        133MB</span><br><span class="line">ubuntu-with-vim         latest              08d108b45e78        2 days ago          514MB</span><br><span class="line">ubuntu-with-vi          latest              126c81439955        2 days ago          131MB</span><br><span class="line">nginx                   latest              f6d0b4767a6c        2 weeks ago         133MB</span><br><span class="line">registry                latest              678dfa38fcfa        6 weeks ago         26.2MB</span><br><span class="line">kesenhuang/ubuntu       16.04               9499db781771        2 months ago        131MB</span><br><span class="line">ubuntu                  16.04               9499db781771        2 months ago        131MB</span><br><span class="line">127.0.0.1:5000/ubuntu   latest              f643c72bc252        2 months ago        72.9MB</span><br><span class="line"></span><br><span class="line">[root@VM-0-11-centos ~]<span class="comment"># docker image  rm 127.0.0.1:5000/ubuntu:latest</span></span><br><span class="line">Untagged: 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">Untagged: 127.0.0.1:5000/ubuntu@sha256:4e4bc990609ed865e07afc8427c30ffdddca5153fd4e82c20d8f0783a291e241</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@VM-0-11-centos ~]<span class="comment"># docker pull 127.0.0.1:5000/ubuntu:latest</span></span><br><span class="line">latest: Pulling from ubuntu</span><br><span class="line">Digest: sha256:4e4bc990609ed865e07afc8427c30ffdddca5153fd4e82c20d8f0783a291e241</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">127.0.0.1:5000/ubuntu:latest</span><br></pre></td></tr></table></figure>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>如果你不想使用 <code>127.0.0.1:5000</code> 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 <code>192.168.199.100:5000</code> 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。</p>
<p>这是因为 Docker 默认不允许非 <code>HTTPS</code> 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 <code>HTTPS</code> 访问的私有仓库。</p>
<h4 id="Ubuntu-14-04-Debian-7-Wheezy"><a href="#Ubuntu-14-04-Debian-7-Wheezy" class="headerlink" title="Ubuntu 14.04, Debian 7 Wheezy"></a>Ubuntu 14.04, Debian 7 Wheezy</h4><p>对于使用 <code>upstart</code> 的系统而言，编辑 <code>/etc/default/docker</code> 文件，在其中的 <code>DOCKER_OPTS</code> 中增加如下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS=<span class="string">&quot;--registry-mirror=https://registry.docker-cn.com --insecure-registries=192.168.199.100:5000&quot;</span></span><br></pre></td></tr></table></figure>

<p>重新启动服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service docker restart</span><br></pre></td></tr></table></figure>

<h4 id="Ubuntu-16-04-Debian-8-centos-7"><a href="#Ubuntu-16-04-Debian-8-centos-7" class="headerlink" title="Ubuntu 16.04+, Debian 8+, centos 7"></a>Ubuntu 16.04+, Debian 8+, centos 7</h4><p>对于使用 <code>systemd</code> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://registry.docker-cn.com&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;192.168.199.100:5000&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：该文件必须符合 <code>json</code> 规范，否则 Docker 将不能启动。</p>
</blockquote>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>对于 Docker for Windows 、 Docker for Mac 在设置中编辑 <code>daemon.json</code> 增加和上边一样的字符串即可。/</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Kesen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/system/docker/">http://example.com/system/docker/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Kesen’s Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/docker/">docker</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/11/15/o6eL9Fk8DZqIJY7.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/02/04/system/jvm/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">jvm</div></div></a></div><div class="next-post pull-right"><a href="/system/linux/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">linux</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.</span> <span class="toc-text">容器生态系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF"><span class="toc-number">1.1.</span> <span class="toc-text">容器核心技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E8%A7%84%E8%8C%83"><span class="toc-number">1.1.1.</span> <span class="toc-text">容器规范</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84runtime"><span class="toc-number">1.1.2.</span> <span class="toc-text">容器的runtime</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7"><span class="toc-number">1.1.3.</span> <span class="toc-text">容器管理工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7"><span class="toc-number">1.1.4.</span> <span class="toc-text">容器定义工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Registry"><span class="toc-number">1.1.5.</span> <span class="toc-text">Registry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8OS"><span class="toc-number">1.1.6.</span> <span class="toc-text">容器OS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF"><span class="toc-number">1.2.</span> <span class="toc-text">容器平台技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E5%BC%95%E6%93%8E"><span class="toc-number">1.2.1.</span> <span class="toc-text">容器编排引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">容器管理平台</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%AE%B9%E5%99%A8%E7%9A%84PaaS"><span class="toc-number">1.2.3.</span> <span class="toc-text">基于容器的PaaS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%94%AF%E6%8C%81%E6%8A%80%E6%9C%AF"><span class="toc-number">1.3.</span> <span class="toc-text">容器支持技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C"><span class="toc-number">1.3.1.</span> <span class="toc-text">容器网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">服务发现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7"><span class="toc-number">1.3.3.</span> <span class="toc-text">监控</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.4.</span> <span class="toc-text">数据管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.5.</span> <span class="toc-text">日志管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">1.3.6.</span> <span class="toc-text">安全性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text">Docker 核心知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#what%E2%80%94%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%B9%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">what—什么是容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">2.1.1.</span> <span class="toc-text">容器与虚拟机</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#why%E2%80%94%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%AE%B9%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">why—为什么需要容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.1.</span> <span class="toc-text">容器解决的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E9%AB%98%E6%95%88%E7%9A%84%E5%88%A9%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">更高效的利用系统资源</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E5%BF%AB%E9%80%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">更快速的启动时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E7%9A%84%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">一致的运行环境</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E5%92%8C%E9%83%A8%E7%BD%B2"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">持续交付和部署</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E8%BD%BB%E6%9D%BE%E7%9A%84%E8%BF%81%E7%A7%BB"><span class="toc-number">2.2.1.5.</span> <span class="toc-text">更轻松的迁移</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E8%BD%BB%E6%9D%BE%E7%9A%84%E7%BB%B4%E6%8A%A4%E5%92%8C%E6%89%A9%E5%B1%95"><span class="toc-number">2.2.1.6.</span> <span class="toc-text">更轻松的维护和扩展</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-%E2%80%94%E5%AE%B9%E5%99%A8%E6%97%B6%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="toc-number">2.3.</span> <span class="toc-text">How —容器时如何工作的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-engine"><span class="toc-number">2.3.1.</span> <span class="toc-text">Docker engine</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="toc-number">2.3.2.</span> <span class="toc-text">Docker 系统架构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-Image"><span class="toc-number">3.</span> <span class="toc-text">Docker Image</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8"><span class="toc-number">3.1.</span> <span class="toc-text">分层存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%95%9C%E5%83%8F"><span class="toc-number">3.2.</span> <span class="toc-text">获取镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E9%95%9C%E5%83%8F"><span class="toc-number">3.3.</span> <span class="toc-text">列出镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4"><span class="toc-number">3.3.1.</span> <span class="toc-text">基础命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E5%B1%82%E9%95%9C%E5%83%8F"><span class="toc-number">3.3.2.</span> <span class="toc-text">中间层镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF"><span class="toc-number">3.3.3.</span> <span class="toc-text">镜像体积</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E9%83%A8%E5%88%86%E9%95%9C%E5%83%8F"><span class="toc-number">3.3.4.</span> <span class="toc-text">列出部分镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E7%89%B9%E5%AE%9A%E6%A0%BC%E5%BC%8F%E6%98%BE%E7%A4%BA"><span class="toc-number">3.3.5.</span> <span class="toc-text">以特定格式显示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F"><span class="toc-number">3.4.</span> <span class="toc-text">删除镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4-1"><span class="toc-number">3.4.1.</span> <span class="toc-text">基础命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="toc-number">3.5.</span> <span class="toc-text">构建镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-commit"><span class="toc-number">3.5.1.</span> <span class="toc-text">docker commit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dockerfile"><span class="toc-number">3.5.2.</span> <span class="toc-text">Dockerfile</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AADemo"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">第一个Demo</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F%E5%88%86%E5%B1%82"><span class="toc-number">3.5.2.2.</span> <span class="toc-text">查看镜像分层</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E5%AE%83-docker-build-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">3.5.2.3.</span> <span class="toc-text">其它 docker build 的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E7%94%A8-Git-repo-%E8%BF%9B%E8%A1%8C%E6%9E%84%E5%BB%BA"><span class="toc-number">3.5.2.3.1.</span> <span class="toc-text">直接用 Git repo 进行构建</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%94%A8%E7%BB%99%E5%AE%9A%E7%9A%84-tar-%E5%8E%8B%E7%BC%A9%E5%8C%85%E6%9E%84%E5%BB%BA"><span class="toc-number">3.5.2.3.2.</span> <span class="toc-text">用给定的 tar 压缩包构建</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dockerfile%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">3.5.3.</span> <span class="toc-text">Dockerfile常用指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#FROM"><span class="toc-number">3.5.3.1.</span> <span class="toc-text">FROM</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MAINTAINER"><span class="toc-number">3.5.3.2.</span> <span class="toc-text">MAINTAINER</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#COPY"><span class="toc-number">3.5.3.3.</span> <span class="toc-text">COPY</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ADD"><span class="toc-number">3.5.3.4.</span> <span class="toc-text">ADD</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ENV"><span class="toc-number">3.5.3.5.</span> <span class="toc-text">ENV</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#EXPOSE"><span class="toc-number">3.5.3.6.</span> <span class="toc-text">EXPOSE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#VOLUME"><span class="toc-number">3.5.3.7.</span> <span class="toc-text">VOLUME</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WORKDIR"><span class="toc-number">3.5.3.8.</span> <span class="toc-text">WORKDIR</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RUN"><span class="toc-number">3.5.3.9.</span> <span class="toc-text">RUN</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CMD"><span class="toc-number">3.5.3.10.</span> <span class="toc-text">CMD</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ENTRYPOINT"><span class="toc-number">3.5.3.11.</span> <span class="toc-text">ENTRYPOINT</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%80%EF%BC%9A%E8%AE%A9%E9%95%9C%E5%83%8F%E5%8F%98%E6%88%90%E5%83%8F%E5%91%BD%E4%BB%A4%E4%B8%80%E6%A0%B7%E4%BD%BF%E7%94%A8"><span class="toc-number">3.5.3.11.1.</span> <span class="toc-text">场景一：让镜像变成像命令一样使用</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E5%AE%B9%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">Docker 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="toc-number">4.1.</span> <span class="toc-text">启动容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E5%B9%B6%E5%90%AF%E5%8A%A8"><span class="toc-number">4.1.1.</span> <span class="toc-text">新建并启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%B7%B2%E7%BB%88%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-number">4.1.2.</span> <span class="toc-text">启动已终止容器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E6%80%81%E8%BF%90%E8%A1%8C"><span class="toc-number">4.2.</span> <span class="toc-text">守护态运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">终止容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="toc-number">4.4.</span> <span class="toc-text">进入容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#attach-%E5%91%BD%E4%BB%A4"><span class="toc-number">4.4.1.</span> <span class="toc-text">attach 命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exec-%E5%91%BD%E4%BB%A4"><span class="toc-number">4.4.2.</span> <span class="toc-text">exec 命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E4%BB%93%E5%BA%93"><span class="toc-number">5.</span> <span class="toc-text">Docker 仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-Hub"><span class="toc-number">5.1.</span> <span class="toc-text">Docker Hub</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C"><span class="toc-number">5.2.</span> <span class="toc-text">注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95"><span class="toc-number">5.3.</span> <span class="toc-text">登录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F"><span class="toc-number">5.4.</span> <span class="toc-text">拉取镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E9%80%81%E9%95%9C%E5%83%8F"><span class="toc-number">5.5.</span> <span class="toc-text">推送镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93"><span class="toc-number">5.6.</span> <span class="toc-text">Docker 私有仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C-docker-registry"><span class="toc-number">5.6.1.</span> <span class="toc-text">安装运行 docker-registry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C"><span class="toc-number">5.6.2.</span> <span class="toc-text">容器运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E4%B8%8A%E4%BC%A0%E3%80%81%E6%90%9C%E7%B4%A2%E3%80%81%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F"><span class="toc-number">5.6.3.</span> <span class="toc-text">在私有仓库上传、搜索、下载镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.6.4.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ubuntu-14-04-Debian-7-Wheezy"><span class="toc-number">5.6.5.</span> <span class="toc-text">Ubuntu 14.04, Debian 7 Wheezy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ubuntu-16-04-Debian-8-centos-7"><span class="toc-number">5.6.6.</span> <span class="toc-text">Ubuntu 16.04+, Debian 8+, centos 7</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">5.6.7.</span> <span class="toc-text">其他</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By Kesen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>
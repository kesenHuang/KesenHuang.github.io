<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kesen’s Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>1985-10-26T08:15:00.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Kesen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/10/27/hello-world/"/>
    <id>http://example.com/2021/10/27/hello-world/</id>
    <published>2021-10-27T03:29:57.026Z</published>
    <updated>1985-10-26T08:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>jvm</title>
    <link href="http://example.com/2021/02/04/system/jvm/"/>
    <id>http://example.com/2021/02/04/system/jvm/</id>
    <published>2021-02-04T01:33:59.000Z</published>
    <updated>2021-02-04T01:33:59.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>docker</title>
    <link href="http://example.com/system/docker/"/>
    <id>http://example.com/system/docker/</id>
    <published>2021-01-24T04:43:39.000Z</published>
    <updated>2021-01-31T07:51:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="容器生态系统"><a href="#容器生态系统" class="headerlink" title="容器生态系统"></a>容器生态系统</h2><p><img src="https://i.loli.net/2021/01/24/6NjQbWXVq3KD8nz.png"></p><h3 id="容器核心技术"><a href="#容器核心技术" class="headerlink" title="容器核心技术"></a>容器核心技术</h3><p>容器核心技术是指能够让Contailer在host上运行起来的技术。</p><p><img src="https://i.loli.net/2021/01/24/SUMo2xCn5tcWIAb.png"></p><h4 id="容器规范"><a href="#容器规范" class="headerlink" title="容器规范"></a>容器规范</h4><p>容器不光是 Docker ，还有其他容器，比如CoreOS 的 rkt. 为了保证容器生态的健康发 展，保证不同容器之间能够兼容，包含 Docker 、Core08、Google 在内的若干公司共同成立了 一 个叫 Open Container lnitiative (OCI)  的组织，其目的是制定开放的容器规范。</p><p>目前 OCI  发布了两个规范: <code>runtime spec</code>  和<code> image format spec</code>.</p><p> 有了这两个规范，不同组织和厂商开发的容器能够在不同的   runtime   上运行 .这样就保证了容器的可移植性和互操作性。</p><h4 id="容器的runtime"><a href="#容器的runtime" class="headerlink" title="容器的runtime"></a>容器的runtime</h4><p>Java 程序就好比是容器， 只叫则好比是 runtime ，JVM  为 Java  程序提供运行环境。同样的道理，容器只有在 runtime  中才能运行。</p><p><code>lxc</code>、<code>runc</code> 和 <code>rkt</code> 是目前主流的三种容器 runtime。</p><ul><li>lxc 是 Linux上老牌的容器 runtime. Docker 最初也是用 lxc 作为 runtime .</li><li>runc  是 Docker  自己开发的容器 runtime ，符合OC1  规范，也是现在 Docker 的默认runtune .</li><li>rkt  是 Core08 开发的容器 runtime ，符合OCI  规范，因而能够运行 Docker 的容器。</li></ul><h4 id="容器管理工具"><a href="#容器管理工具" class="headerlink" title="容器管理工具"></a>容器管理工具</h4><p>光有 runtJme 还不够，用户得有工具来管理容器。容器管理工具对内与 runtlme 交互， 对外为用户提供 interface ，比如CLI 。</p><ul><li><code>lxd</code> 是 lxc 对应的管理工具 。</li><li>runc 的管理工具是 <code>docker engine</code>。 docker engine 包含后台 deamon 和 cli 两个部分。我们 通常提到 Docker。 一般就是指的 docker engine。</li><li>rkt 的管理工具是 <code>rkt cli</code>.</li></ul><h4 id="容器定义工具"><a href="#容器定义工具" class="headerlink" title="容器定义工具"></a>容器定义工具</h4><p>容器定义工具 容器定义工具允许用户定义容器的内容和属性，这样容器就能够被保存、共享和重建。</p><ul><li><code>docker image</code> 是 Docker 容器的模板. runtime 依据 docker image 创建容器。</li><li><code>dockerfile</code> 是包含若干命令的文本文件，可以通过这些命令创建出 docker image .</li><li><code>ACI (App Container Image)</code>  与 docker image 类似，只不过它是由 CoreOS  开发的出容器 的 image格式 。</li></ul><h4 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h4><p>容器是通过 image  创建的，需要有一个仓库来统 一存放 lmage ，这个仓库就叫做Registry 。</p><ul><li>企业可以用 Docker Registry 构建私有的 Registry 。</li><li>Docker  Hub  ( <a href="https://hub.docker.com/">https://hub.docker.com</a>)   是 Docker  为公众提供的托管 Registry，上面有很多现成的 image。为 Docker 用户提供了极大的便利 。</li><li>Quay.io  (<a href="https://quay.io/">https://quay.io/</a>)  是另一个公共托管Registry，提供与 DockerHub 类似的服务。</li></ul><h4 id="容器OS"><a href="#容器OS" class="headerlink" title="容器OS"></a>容器OS</h4><p>由于有容器 runtime ，几乎所有的linux、 MAC  OS 和 Windows  都可以运行容器，但这并没有妨碍容器 OS 的问世。</p><p>容器 OS  是专门运行容器的操作系统。与常规OS 相比，容器OS  通常体积更小，启动更快。因为是为容器定制的 OS. 通常它们运行容器的效率会更高。</p><h3 id="容器平台技术"><a href="#容器平台技术" class="headerlink" title="容器平台技术"></a>容器平台技术</h3><p>容器核心技术使得容器能够在单个 host 上运行，==而容器平台技术能够让容器作为集群在分布式环境中运行== 。</p><p><img src="https://i.loli.net/2021/01/24/5C71FA3VTxHOK8c.png"></p><h4 id="容器编排引擎"><a href="#容器编排引擎" class="headerlink" title="容器编排引擎"></a>容器编排引擎</h4><p>基于容器的应用一般会采用微服务架构。在这种架构下，应用被划分为不同的组件，并以 服务的形式运行在各自的容器中，通过 API  对外提供服务。为了保证应用的高可用，每个组件 都可能会运行多个相同的容器。这些容器会组成集群，集群中的容器会根据业务需要被动态地 创建、迁移和销毁。</p><p>这样一个基于微服务架构的应用系统实际上是 一个动态的可伸缩的系统。 这对我们的部署环境提出了新的要求，我们需要有一种高效的方法来==管理容器集群==。而这，就是容器编排引擎要干的工作。</p><p>所谓编排 (orchestration )  。通常包括容器管理、调度、集群定义和服务发现等。通过容器 编排引擎，容器被有机地组合成微服务应用，实现业务需求。</p><ul><li>docker swarm 是 Docker 开发的容器编排引擎 。</li><li>kubernetes  是 Google  领导开发的开源容器编排引擎，同时支持 Docker  和 CoreOS容器 。</li><li>mesos是一个通用的集群资源调度平台， mesos 与 marathon 一起提供容器编排引擎功能。 </li></ul><h4 id="容器管理平台"><a href="#容器管理平台" class="headerlink" title="容器管理平台"></a>容器管理平台</h4><p>容器管理平台是架构在容器编排引擎之上的 一个更为通用的平台。通常容器管理平台能够 支持多种编排引擎，抽象了编排引擎的底层实现细节，为用户提供更方便的功能 ，比如 application catalog  和一键应用部署等。</p><p>Rancher 和 ContainerShip 是容器管理平台的典型代表。</p><h4 id="基于容器的PaaS"><a href="#基于容器的PaaS" class="headerlink" title="基于容器的PaaS"></a>基于容器的PaaS</h4><p>基于容器的 PaaS  为微服务应用开发人员和公司提供了开发、部署和管理应用的平台 ，使用户不必关心底层基础设施而专注于应用的开发。</p><h3 id="容器支持技术"><a href="#容器支持技术" class="headerlink" title="容器支持技术"></a>容器支持技术</h3><p>用于支持基于容器的基础设施相干技术。</p><p><img src="https://i.loli.net/2021/01/24/KhIaGTOR26LHC7b.png" alt="image.png"></p><h4 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h4><p>容器的出现使网络拓扑变得更加动态和复杂。用户需要专门的解决方案来管理容器与容器、容器与其他实体之间的连通性和隔离性。</p><ul><li>docker network 是 Docker 原生的网络解决方案。</li><li>除此之外，我们还可以采用第三方开源解决方案，例如 flanne1、weave 和 calico。不同方案的设计和实现方式不同，各有优势和特点， 应根据实际需要来选型。</li></ul><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><p>动态变化是微服务应用的一大特点。当负载增加时，集群会自动创建新的容器:负载减小，多余的容器会被销毁。容器也会根据 host 的资源使用情况在不同 host 中迁移，容器的IP和端口也会随之发生变化。</p><p>在这种动态的环镜下，必须要有一种机制让 client  能够知道如何访问容器提供的服务。这就是服务发现技术要完成的工作。</p><p>服务发现会保存容器集群中所有微服务最新的信息，比如 IP 和端口，并对外提供 API。提供服务查询功能。</p><p>etcd 、consu1  和 zookeeper  是服务发现的典型解决方案。</p><h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h4><p>监控对于基础架构非常重要，而容器的动态特征对监控提出更多挑战。针对容器环境，已经涌现出很多监控工具和方案</p><p>docker ps/top/stats是 Docker  原生的命令行监控工具。除了命令行， Docker 也提供了stats API ，用户可以通过HTIP 请求获取容器的状态信息。</p><p>sysdig、 cAdvisor/Heapster 和 WeaveScope 是其他开源的容器监控方案。</p><h4 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h4><p>容器经常会在不同的 host  之间迁移，如何保证持久化数据也能够动态迁移，是 Rex-Ray这类数据管理工具提供的能力</p><h4 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h4><p>日志为问题排查和事件管理提供了重要依据。日志工具有两类：</p><ul><li>docker logs 是 Docker 原生的日志工具。</li><li>而 logspout 对日志提供了路由功能，它可以收集不同容器的日志并转发给其他工具进行后处理 。</li></ul><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>对于年轻的容器，安全性 一直是业界争论的焦点。  OpenSCAP 是一种容器安全工具。OpenSCAP  能够对容器镜像进行扫描，发现潜在的漏洞。</p><h2 id="Docker-核心知识"><a href="#Docker-核心知识" class="headerlink" title="Docker 核心知识"></a>Docker 核心知识</h2><h3 id="what—什么是容器"><a href="#what—什么是容器" class="headerlink" title="what—什么是容器"></a>what—什么是容器</h3><p>Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 <a href="https://en.wikipedia.org/wiki/Docker_(software)">2013 年 3 月以 Apache 2.0 授权协议开源</a>，主要项目代码在 <a href="https://github.com/moby/moby">GitHub</a> 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 <a href="https://www.opencontainers.org/">开放容器联盟（OCI）</a>。</p><p>Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目已经超过 4 万 6 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，<a href="https://blog.docker.com/2013/10/dotcloud-is-becoming-docker-inc/">dotCloud 公司决定改名为 Docker</a>。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。</p><p>Docker 使用 Google 公司推出的 <a href="https://golang.org/">Go 语言</a> 进行开发实现，基于 Linux 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces">namespace</a>，以及 <a href="https://en.wikipedia.org/wiki/Aufs">AUFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/">LXC</a>，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 <a href="https://github.com/docker/libcontainer">libcontainer</a>，从 1.11 开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc">runC</a> 和 <a href="https://github.com/containerd/containerd">containerd</a>。</p><p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p><h4 id="容器与虚拟机"><a href="#容器与虚拟机" class="headerlink" title="容器与虚拟机"></a>容器与虚拟机</h4><p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><p><img src="https://i.loli.net/2021/01/24/drcyhKolWp2ZetI.png"></p><p><img src="https://i.loli.net/2021/01/24/bEaWjAtvfSTCHF4.png"></p><h3 id="why—为什么需要容器"><a href="#why—为什么需要容器" class="headerlink" title="why—为什么需要容器"></a>why—为什么需要容器</h3><h4 id="容器解决的问题"><a href="#容器解决的问题" class="headerlink" title="容器解决的问题"></a>容器解决的问题</h4><p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势</p><h5 id="更高效的利用系统资源"><a href="#更高效的利用系统资源" class="headerlink" title="更高效的利用系统资源"></a>更高效的利用系统资源</h5><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><h5 id="更快速的启动时间"><a href="#更快速的启动时间" class="headerlink" title="更快速的启动时间"></a>更快速的启动时间</h5><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p><h5 id="一致的运行环境"><a href="#一致的运行环境" class="headerlink" title="一致的运行环境"></a>一致的运行环境</h5><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 <em>「这段代码在我机器上没问题啊」</em> 这类问题。</p><h5 id="持续交付和部署"><a href="#持续交付和部署" class="headerlink" title="持续交付和部署"></a>持续交付和部署</h5><p>对开发和运维（<a href="https://zh.wikipedia.org/wiki/DevOps">DevOps</a>）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p><p>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 <code>Dockerfile</code> 来进行镜像构建，并结合 <a href="https://en.wikipedia.org/wiki/Continuous_integration">持续集成(Continuous Integration)</a> 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 <a href="https://en.wikipedia.org/wiki/Continuous_delivery">持续部署(Continuous Delivery/Deployment)</a> 系统进行自动部署。</p><p>而且使用 <code>Dockerfile</code> 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像</p><h5 id="更轻松的迁移"><a href="#更轻松的迁移" class="headerlink" title="更轻松的迁移"></a>更轻松的迁移</h5><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><h5 id="更轻松的维护和扩展"><a href="#更轻松的维护和扩展" class="headerlink" title="更轻松的维护和扩展"></a>更轻松的维护和扩展</h5><p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 <a href="https://store.docker.com/search?q=&source=verified&type=image">官方镜像</a>，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本</p><h3 id="How-—容器时如何工作的"><a href="#How-—容器时如何工作的" class="headerlink" title="How —容器时如何工作的"></a>How —容器时如何工作的</h3><h4 id="Docker-engine"><a href="#Docker-engine" class="headerlink" title="Docker engine"></a>Docker engine</h4><p>Docker 引擎是一个包含以下主要组件的客户端服务器应用程序。</p><ul><li>一种服务器，它是一种称为守护进程并且长时间运行的程序。</li><li>REST API用于指定程序可以用来与守护进程通信的接口，并指示它做什么。</li><li>一个有命令行界面 (CLI) 工具的客户端。</li></ul><p>Docker 引擎组件的流程如下图所示：</p><p><img src="https://i.loli.net/2021/01/24/xMI6y4chiYqtNG5.png" alt="image.png"></p><h4 id="Docker-系统架构"><a href="#Docker-系统架构" class="headerlink" title="Docker 系统架构"></a>Docker 系统架构</h4><p>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程 API 来管理和创建 Docker 容器。</p><p>Docker 容器通过 Docker 镜像来创建。</p><p>容器与镜像的关系类似于面向对象编程中的对象与类。</p><table><thead><tr><th align="left">Docker</th><th align="left">面向对象</th></tr></thead><tbody><tr><td align="left">容器</td><td align="left">对象</td></tr><tr><td align="left">镜像</td><td align="left">类</td></tr></tbody></table><p><img src="https://i.loli.net/2021/01/24/wPmJEKRWnB1fM37.png" alt="image.png"></p><table><thead><tr><th align="left">标题</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">镜像(Images)</td><td align="left">Docker 镜像是用于创建 Docker 容器的模板。</td></tr><tr><td align="left">容器(Container)</td><td align="left">容器是独立运行的一个或一组应用。</td></tr><tr><td align="left">客户端(Client)</td><td align="left">Docker 客户端通过命令行或者其他工具使用 Docker API (<a href="https://docs.docker.com/reference/api/docker_remote_api">https://docs.docker.com/reference/api/docker_remote_api</a>) 与 Docker 的守护进程通信。</td></tr><tr><td align="left">Docker daemon</td><td align="left">服务器组件，以Linux后台服务的方式运行，Docker daemon运行在Docker host上，负责创建、运行、监控容器，构建、存储镜像。<br/>默认配置下Docker daemon只能响应本地Host的客户端请求。</td></tr><tr><td align="left">主机(Host)</td><td align="left">一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td></tr><tr><td align="left">仓库(Registry)</td><td align="left">Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(<a href="https://hub.docker.com/">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。</td></tr><tr><td align="left">Docker Machine</td><td align="left">Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</td></tr></tbody></table><h2 id="Docker-Image"><a href="#Docker-Image" class="headerlink" title="Docker Image"></a>Docker Image</h2><h3 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h3><p>操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:16.04</code> 就包含了完整的一套 Ubuntu 16.04 最小系统的 <code>root</code> 文件系统。</p><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变</p><p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure><p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，这里我们说一下镜像名称的格式。</p><ul><li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub。</li><li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li></ul><p>比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker pull ubuntu:16.04</span></span><br><span class="line">16.04: Pulling from library/ubuntu</span><br><span class="line">bf5d46315322: Pull complete</span><br><span class="line">9f13e0ac480c: Pull complete</span><br><span class="line">e8988b5b3097: Pull complete</span><br><span class="line">40af181810e7: Pull complete</span><br><span class="line">e6f7c7e5c03e: Pull complete</span><br><span class="line">Digest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe</span><br><span class="line">Status: Downloaded newer image for ubuntu:16.04</span><br></pre></td></tr></table></figure><p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 <code>ubuntu:16.04</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>16.04</code> 的镜像。</p><p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 <code>sha256</code> 的摘要，以确保下载一致性。</p><p>在使用上面命令的时候，你可能会发现，你所看到的层 ID 以及 <code>sha256</code> 的摘要和这里的不一样。这是因为官方镜像是一直在维护的，有任何新的 bug，或者版本更新，都会进行修复再以原来的标签发布，这样可以确保任何使用这个标签的用户可以获得更安全、更稳定的镜像。</p><p><em>如果从 Docker Hub 下载镜像非常缓慢，可以参照 <code>镜像加速器</code> 一节配置加速器。</em></p><h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">docker image ls </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos ~]# docker images</span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu-with-vim      latest              08d108b45e78        23 hours ago        514MB</span><br><span class="line">ubuntu-with-vi       latest              126c81439955        24 hours ago        131MB</span><br><span class="line">ubuntu               16.04               9499db781771        2 months ago        131MB</span><br><span class="line">ubuntu               latest              f643c72bc252        2 months ago        72.9MB</span><br><span class="line">postgres             9.5                 693ab34b0689        2 months ago        197MB</span><br><span class="line">mysql                5.7                 c791733bf9b7        2 months ago        449MB</span><br><span class="line">hello-world          latest              bf756fb1ae65        13 months ago       13.3kB</span><br><span class="line">jaspeen/oracle-11g   latest              0c8711fe4f0f        5 years ago         281MB</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos ~]# docker image ls </span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu-with-vim      latest              08d108b45e78        23 hours ago        514MB</span><br><span class="line">ubuntu-with-vi       latest              126c81439955        24 hours ago        131MB</span><br><span class="line">ubuntu               16.04               9499db781771        2 months ago        131MB</span><br><span class="line">ubuntu               latest              f643c72bc252        2 months ago        72.9MB</span><br><span class="line">postgres             9.5                 693ab34b0689        2 months ago        197MB</span><br><span class="line">mysql                5.7                 c791733bf9b7        2 months ago        449MB</span><br><span class="line">hello-world          latest              bf756fb1ae65        13 months ago       13.3kB</span><br><span class="line">jaspeen/oracle-11g   latest              0c8711fe4f0f        5 years ago         281MB</span><br></pre></td></tr></table></figure><h4 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h4><p>为了加速镜像构建、重复利用资源，Docker 会利用 <strong>中间层镜像</strong>。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 <code>docker image ls</code> 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 <code>-a</code> 参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls -a </span><br></pre></td></tr></table></figure><h4 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h4><p><code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。以下命令来便捷的查看镜像、容器、数据卷所占用的空间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system df </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos ~]# docker system df </span><br><span class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</span><br><span class="line">Images              8                   6                   1.514GB             609MB (40%)</span><br><span class="line">Containers          7                   0                   383.7MB             383.7MB (100%)</span><br><span class="line">Local Volumes       1                   1                   207.2MB             0B (0%)</span><br><span class="line">Build Cache         0                   0                   0B                  0B</span><br></pre></td></tr></table></figure><h4 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h4><p>根据仓库名列出镜像，可以自动补齐（Tab键）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls ubuntu</span><br></pre></td></tr></table></figure><p>列出特定的某个镜像，也就是说指定仓库名和标签，可以自动补齐（Tab键）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">docker image ls ubuntu:16.04</span><br></pre></td></tr></table></figure><p>除此以外，<code>docker image ls</code> 还支持强大的过滤器参数 <code>--filter</code>，或者简写 <code>-f</code></p><h4 id="以特定格式显示"><a href="#以特定格式显示" class="headerlink" title="以特定格式显示"></a>以特定格式显示</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos ~]# docker image ls -q</span><br><span class="line">08d108b45e78</span><br><span class="line">126c81439955</span><br><span class="line">9499db781771</span><br><span class="line">f643c72bc252</span><br><span class="line">693ab34b0689</span><br><span class="line">c791733bf9b7</span><br><span class="line">bf756fb1ae65</span><br><span class="line">0c8711fe4f0f</span><br></pre></td></tr></table></figure><p>==GO语法模板==</p><p>只包含镜像ID和仓库名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">oot@VM-0-11-centos ~]# docker image ls --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</span><br><span class="line">08d108b45e78: ubuntu-with-vim</span><br><span class="line">126c81439955: ubuntu-with-vi</span><br><span class="line">9499db781771: ubuntu</span><br><span class="line">f643c72bc252: ubuntu</span><br><span class="line">693ab34b0689: postgres</span><br><span class="line">c791733bf9b7: mysql</span><br><span class="line">bf756fb1ae65: hello-world</span><br><span class="line">0c8711fe4f0f: jaspeen/oracle-11g</span><br><span class="line">[root@VM-0-11-centos ~]# </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos ~]# docker image ls --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;&quot;</span><br><span class="line">IMAGE ID            REPOSITORY           TAG</span><br><span class="line">08d108b45e78        ubuntu-with-vim      latest</span><br><span class="line">126c81439955        ubuntu-with-vi       latest</span><br><span class="line">9499db781771        ubuntu               16.04</span><br><span class="line">f643c72bc252        ubuntu               latest</span><br><span class="line">693ab34b0689        postgres             9.5</span><br><span class="line">c791733bf9b7        mysql                5.7</span><br><span class="line">bf756fb1ae65        hello-world          latest</span><br><span class="line">0c8711fe4f0f        jaspeen/oracle-11g   latest</span><br></pre></td></tr></table></figure><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><h4 id="基础命令-1"><a href="#基础命令-1" class="headerlink" title="基础命令"></a>基础命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p><p>可以使用 <code>docker image ls -q</code> 来配合使用 <code>docker image rm</code>，这样可以成批的删除希望删除的镜像。</p><p>比如，需要删除所有仓库名为 <code>redis</code> 的镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm $(docker image ls -q redis)</span><br></pre></td></tr></table></figure><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><h4 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h4><p>步骤：</p><ol><li>运行容器</li><li>修改容器</li><li>将容器报存为新的镜像</li></ol><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><p>Dockerfile 是一个文本文件，其内包含了一条条的**指令(Instruction)**，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><h5 id="第一个Demo"><a href="#第一个Demo" class="headerlink" title="第一个Demo"></a>第一个Demo</h5><ul><li>在空白目录下新建目录，并创建 Dockerfile文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos data]# mkdir mynginx</span><br><span class="line">[root@VM-0-11-centos data]# cd mynginx/</span><br><span class="line">[root@VM-0-11-centos mynginx]# touch Dockerfile</span><br></pre></td></tr></table></figure><ul><li>Dockerfile内容为：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure><ul><li>执行docker build命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos mynginx]# docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/2 : FROM nginx</span><br><span class="line">latest: Pulling from library/nginx</span><br><span class="line">a076a628af6f: Pull complete </span><br><span class="line">0732ab25fa22: Pull complete </span><br><span class="line">d7f36f6fe38f: Pull complete </span><br><span class="line">f72584a26f32: Pull complete </span><br><span class="line">7125e4df9063: Pull complete </span><br><span class="line">Digest: sha256:10b8cc432d56da8b61b070f4c7d2543a9ed17c2b23010b43af434fd40e2ca4aa</span><br><span class="line">Status: Downloaded newer image for nginx:latest</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> f6d0b4767a6c</span></span><br><span class="line">Step 2/2 : RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 2ddb4b16e777</span></span><br><span class="line">Removing intermediate container 2ddb4b16e777</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> d8429783e126</span></span><br><span class="line">Successfully built d8429783e126</span><br><span class="line">Successfully tagged nginx:v3</span><br></pre></td></tr></table></figure><p><code>. </code>指定build context为当前目录，Docker 默认会从build context中查找Dockerfile文件，可以通过-f 参数指定Dockerfile的位置。这是在指定<strong>上下文路径</strong>。</p><p>当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p><p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p><p>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p><blockquote><p>总结：</p></blockquote><ol><li>从base镜像运行一个容器</li><li>执行一条命令，对容器进行修改</li><li>执行类型docker commit的操作，生成一个新的镜像层</li><li>Docker 再基于刚刚的镜像运行一个新容器</li><li>重复2-4步，直到Dockerfile中的所有指令执行完毕</li></ol><h5 id="查看镜像分层"><a href="#查看镜像分层" class="headerlink" title="查看镜像分层"></a>查看镜像分层</h5><p>docker history 会显示镜像的构建历史，也就是Dockerfile的执行过程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker histroy</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos /]# docker history nginx:v3 </span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE        COMMENT</span><br><span class="line">d8429783e126        13 minutes ago      /bin/sh -c echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; …   24B     </span><br><span class="line">f6d0b4767a6c        2 weeks ago         /bin/sh -c #(nop)  CMD [&quot;nginx&quot; &quot;-g&quot; &quot;daemon…   0B     </span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop)  STOPSIGNAL SIGQUIT           0B     </span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop)  EXPOSE 80                    0B     </span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop)  ENTRYPOINT [&quot;/docker-entr…   0B     </span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop) COPY file:0fd5fca330dcd6a7…   1.04kB </span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop) COPY file:0b866ff3fc1ef5b0…   1.96kB </span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop) COPY file:e7e183879c35719c…   1.2kB   </span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c set -x     &amp;&amp; addgroup --system -…   63.7MB  &lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop)  ENV PKG_RELEASE=1~buster     0B</span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop)  ENV NJS_VERSION=0.5.0        0B     </span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop)  ENV NGINX_VERSION=1.19.6     0B     </span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop)  LABEL maintainer=NGINX Do…   0B     </span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop)  CMD [&quot;bash&quot;]                 0B     </span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop) ADD file:422aca8901ae3d869…   69.2MB </span><br></pre></td></tr></table></figure><p>注：missing表示无法获取IMAGE ID，通常从Docker Hub下载的镜像会有这个问题</p><h5 id="其它-docker-build-的用法"><a href="#其它-docker-build-的用法" class="headerlink" title="其它 docker build 的用法"></a>其它 <code>docker build</code> 的用法</h5><h6 id="直接用-Git-repo-进行构建"><a href="#直接用-Git-repo-进行构建" class="headerlink" title="直接用 Git repo 进行构建"></a>直接用 Git repo 进行构建</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build https://github.com/twang2218/gitlab-ce-zh.git</span><br></pre></td></tr></table></figure><h6 id="用给定的-tar-压缩包构建"><a href="#用给定的-tar-压缩包构建" class="headerlink" title="用给定的 tar 压缩包构建"></a>用给定的 tar 压缩包构建</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build http://server/context.tar.gz</span><br></pre></td></tr></table></figure><h4 id="Dockerfile常用指令"><a href="#Dockerfile常用指令" class="headerlink" title="Dockerfile常用指令"></a>Dockerfile常用指令</h4><h5 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h5><p>指定base镜像</p><h5 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h5><p>设置镜像作者</p><h5 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h5><p>将文件从build context 复制到镜像</p><p><code>COPY</code>支持两种形式：COPY  src dest 与 COPY[“src”, “desc”]。</p><p>注意：src只能指定build context中的文件或目录</p><p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY package.json /usr/src/app/</span><br></pre></td></tr></table></figure><p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><h5 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h5><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</p><p>从build context复制文件到镜像，如果src是归档文件（tar、zip、tgz、xz等），文件会被自动解约到dest。</p><p>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 <code>ADD</code> 命令了。</p><p>在 Docker 官方的 <code>Dockerfile 最佳实践文档</code> 中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</p><p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code></p><h5 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h5><p>设置环境变量。</p><p>格式有两种：</p><ul><li><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li></ul><p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 <code>node</code> 镜像 <code>Dockerfile</code> 中，就有类似这样的代码：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> NODE_VERSION <span class="number">7.2</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span></span><br><span class="line"><span class="bash">  &amp;&amp; curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span> \</span></span><br><span class="line"><span class="bash">  &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \</span></span><br><span class="line"><span class="bash">  &amp;&amp; grep <span class="string">&quot; node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz\$&quot;</span> SHASUMS256.txt | sha256sum -c - \</span></span><br><span class="line"><span class="bash">  &amp;&amp; tar -xJf <span class="string">&quot;node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> -C /usr/<span class="built_in">local</span> --strip-components=1 \</span></span><br><span class="line"><span class="bash">  &amp;&amp; rm <span class="string">&quot;node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> SHASUMS256.txt.asc SHASUMS256.txt \</span></span><br><span class="line"><span class="bash">  &amp;&amp; ln -s /usr/<span class="built_in">local</span>/bin/node /usr/<span class="built_in">local</span>/bin/nodejs</span></span><br></pre></td></tr></table></figure><p>在这里先定义了环境变量 <code>NODE_VERSION</code>，其后的 <code>RUN</code> 这层里，多次使用 <code>$NODE_VERSION</code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 <code>7.2.0</code> 即可，<code>Dockerfile</code> 构建维护变得更轻松了。</p><p>下列指令可以支持环境变量展开： <code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code>。</p><p>可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 <code>Dockerfile</code> 制作更多的镜像，只需使用不同的环境变量即可</p><h5 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h5><p>指定容器中的进程会监听某个端口，Docker可以将该端口暴露出去。</p><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p><p><code>EXPOSE</code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p><p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p><h5 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h5><p>将文件或者目录声明为volume。</p><p>格式为：</p><ul><li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li><li><code>VOLUME &lt;路径&gt;</code></li></ul><h5 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h5><p>为后面的RUN、CMD、ENTRY、ADD或COPY指令设置镜像中的当前工作目录。</p><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p><p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p><p>之前提到一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; world.txt</span></span><br></pre></td></tr></table></figure><p>如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 <code>Dockerfile</code> 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 <code>Dockerfile</code> 构建分层存储的概念不了解所导致的错误。</p><p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p><p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令</p><h5 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h5><p>在容器中运行指定的命令</p><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li><p><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure></li><li><p><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</p></li></ul><h5 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h5><p>容器启动时运行指定的命令。</p><p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p><ul><li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li><li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li><li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li></ul><p>Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。</p><p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p><p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>&quot;</code>，而不要使用单引号。</p><p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$HOME</span></span></span><br></pre></td></tr></table></figure><p>在实际执行中，会将其变更为：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo <span class="variable">$HOME</span>&quot;</span> ]</span></span><br></pre></td></tr></table></figure><h5 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h5><p>设置容器启动时运行的命令。</p><p>Dockerfile中可以有多个ENTRYPOINT指令，但只有最后一个生效。CMD或docker run 之后的参数会被当作参数传递给ENTRYPOINT。</p><p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。</p><p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。</p><p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; <span class="string">&quot;&lt;CMD&gt;&quot;</span></span><br></pre></td></tr></table></figure><p>那么有了 <code>CMD</code> 后，为什么还要有 <code>ENTRYPOINT</code> 呢？这种 <code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code> 有什么好处么？让我们来看几个场景。</p><h6 id="场景一：让镜像变成像命令一样使用"><a href="#场景一：让镜像变成像命令一样使用" class="headerlink" title="场景一：让镜像变成像命令一样使用"></a>场景一：让镜像变成像命令一样使用</h6><p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 <code>CMD</code> 来实现：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install -y curl \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://ip.cn&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>假如我们使用 <code>docker build -t myip .</code> 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip</span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br></pre></td></tr></table></figure><p>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 <code>CMD</code> 中可以看到实质的命令是 <code>curl</code>，那么如果我们希望显示 HTTP 头信息，就需要加上 <code>-i</code> 参数。那么我们可以直接加 <code>-i</code> 参数给 <code>docker run myip</code> 么？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip -i</span><br><span class="line">docker: Error response from daemon: invalid header field value <span class="string">&quot;oci runtime error: container_linux.go:247: starting container process caused \&quot;exec: \\\&quot;-i\\\&quot;: executable file not found in <span class="variable">$PATH</span>\&quot;\n&quot;</span>.</span><br></pre></td></tr></table></figure><p>我们可以看到可执行文件找不到的报错，<code>executable file not found</code>。之前我们说过，跟在镜像名后面的是 <code>command</code>，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了原来的 <code>CMD</code>，而不是添加在原来的 <code>curl -s http://ip.cn</code> 后面。而 <code>-i</code> 根本不是命令，所以自然找不到。</p><p>那么如果我们希望加入 <code>-i</code> 这参数，我们就必须重新完整的输入这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip curl -s http://ip.cn -i</span><br></pre></td></tr></table></figure><p>这显然不是很好的解决方案，而使用 <code>ENTRYPOINT</code> 就可以解决这个问题。现在我们重新用 <code>ENTRYPOINT</code> 来实现这个镜像：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install -y curl \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://ip.cn&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>这次我们再来尝试直接使用 <code>docker run myip -i</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip</span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br><span class="line"></span><br><span class="line">$ docker run myip -i</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.8.0</span><br><span class="line">Date: Tue, 22 Nov 2016 05:12:40 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Powered-By: PHP/5.6.24-1~dotdeb+7.1</span><br><span class="line">X-Cache: MISS from cache-2</span><br><span class="line">X-Cache-Lookup: MISS from cache-2:80</span><br><span class="line">X-Cache: MISS from proxy-2_6</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Via: 1.1 cache-2:80, 1.1 proxy-2_6:8006</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br></pre></td></tr></table></figure><p>可以看到，这次成功了。这是因为当存在 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的内容将会作为参数传给 <code>ENTRYPOINT</code>，而这里 <code>-i</code> 就是新的 <code>CMD</code>，因此会作为参数传给 <code>curl</code>，从而达到了我们预期的效果。</p><h2 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h2><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>stopped</code>）的容器重新启动。</p><p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p><h4 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h4><p>所需要的命令主要为 <code>docker run</code>。</p><p>在讨论Dockerfile时，可用三种方式指定容器启动时执行的命令：</p><ul><li>CMD</li><li>ENTRYPOINT</li><li>docker run命令行中指定</li></ul><p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run ubuntu:14.04 /bin/<span class="built_in">echo</span> <span class="string">&#x27;Hello world&#x27;</span></span><br></pre></td></tr></table></figure><p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i ubuntu:14.04 /bin/bash</span><br><span class="line">root@af8bae53bdd3:/<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h4 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h4><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止的容器启动运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container start</span><br></pre></td></tr></table></figure><h3 id="守护态运行"><a href="#守护态运行" class="headerlink" title="守护态运行"></a>守护态运行</h3><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p><p>下面举两个例子来说明一下。</p><p>如果不使用 <code>-d</code> 参数运行容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos myip]<span class="comment"># docker run ubuntu:16.04  /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p><p>如果使用了 <code>-d</code> 参数运行容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos myip]<span class="comment"># docker run -d ubuntu:16.04  /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;  </span></span><br><span class="line">5173b19b14c49aa98c83f11466e56311411e61f21d3db798afe4095efef61f3a</span><br></pre></td></tr></table></figure><p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker logs</code> 查看)。</p><p><strong>注：</strong> 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p><p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p><p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos myip]<span class="comment"># docker container ls </span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                  NAMES</span><br><span class="line">5173b19b14c4        ubuntu:16.04        <span class="string">&quot;/bin/sh -c &#x27;while t…&quot;</span>   About a minute ago   Up About a minute                          sharp_bohr</span><br><span class="line">99a009bbe1f8        nginx               <span class="string">&quot;/docker-entrypoint.…&quot;</span>   8 hours ago          Up 8 hours          0.0.0.0:8080-&gt;80/tcp   nginx-demo</span><br></pre></td></tr></table></figure><p>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos myip]<span class="comment"># docker container logs 5173b19b14c4</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器。</p><p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p><p>例如对于上一章节中只启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p><p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -a</span><br></pre></td></tr></table></figure><p>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。</p><p>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p><p>某些时候需要进入容器进行操作，包括使用 </p><p><code>docker attach</code> </p><p> <code>docker exec</code></p><h4 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a><code>attach</code> 命令</h4><p><code>docker attach</code> 是 Docker 自带的命令。下面示例如何使用该命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看运行中的容器</span></span><br><span class="line">[root@VM-0-11-centos myip]<span class="comment"># docker container ls </span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES</span><br><span class="line">5173b19b14c4        ubuntu:16.04        <span class="string">&quot;/bin/sh -c &#x27;while t…&quot;</span>   10 minutes ago      Up 10 minutes                              sharp_bohr</span><br><span class="line">99a009bbe1f8        nginx               <span class="string">&quot;/docker-entrypoint.…&quot;</span>   8 hours ago         Up 8 hours          0.0.0.0:8080-&gt;80/tcp   nginx-demo</span><br><span class="line"><span class="comment"># 进入该容器</span></span><br><span class="line">[root@VM-0-11-centos myip]<span class="comment"># docker attach 517</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line"><span class="comment"># 退出后查看运行中的容器</span></span><br><span class="line">[root@VM-0-11-centos myip]<span class="comment"># docker container ls </span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES</span><br><span class="line">99a009bbe1f8        nginx               <span class="string">&quot;/docker-entrypoint.…&quot;</span>   8 hours ago         Up 8 hours          0.0.0.0:8080-&gt;80/tcp   nginx-demo</span><br><span class="line">[root@VM-0-11-centos myip]<span class="comment"># </span></span><br></pre></td></tr></table></figure><p>如果从这个 stdin 中 exit，会导致容器的停止</p><h4 id="exec-命令"><a href="#exec-命令" class="headerlink" title="exec 命令"></a><code>exec</code> 命令</h4><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p><p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos myip]<span class="comment"># docker exec -it 99a009bbe1f8 bash</span></span><br><span class="line">root@99a009bbe1f8:/<span class="comment"># ls -al</span></span><br><span class="line">total 88</span><br><span class="line">drwxr-xr-x  1 root root 4096 Jan 30 01:39 .</span><br><span class="line">drwxr-xr-x  1 root root 4096 Jan 30 01:39 ..</span><br><span class="line">-rwxr-xr-x  1 root root    0 Jan 30 01:39 .dockerenv</span><br><span class="line">drwxr-xr-x  2 root root 4096 Jan 11 00:00 bin</span><br><span class="line">drwxr-xr-x  2 root root 4096 Nov 22 12:37 boot</span><br><span class="line">drwxr-xr-x  5 root root  340 Jan 30 01:39 dev</span><br><span class="line">drwxr-xr-x  1 root root 4096 Jan 12 10:17 docker-entrypoint.d</span><br><span class="line">-rwxrwxr-x  1 root root 1202 Jan 12 10:16 docker-entrypoint.sh</span><br><span class="line">drwxr-xr-x  1 root root 4096 Jan 30 01:39 etc</span><br><span class="line">drwxr-xr-x  2 root root 4096 Nov 22 12:37 home</span><br><span class="line">drwxr-xr-x  1 root root 4096 Jan 12 10:17 lib</span><br><span class="line">drwxr-xr-x  2 root root 4096 Jan 11 00:00 lib64</span><br><span class="line">drwxr-xr-x  2 root root 4096 Jan 11 00:00 media</span><br><span class="line">drwxr-xr-x  2 root root 4096 Jan 11 00:00 mnt</span><br><span class="line">drwxr-xr-x  2 root root 4096 Jan 11 00:00 opt</span><br><span class="line">dr-xr-xr-x 93 root root    0 Jan 30 01:39 proc</span><br><span class="line">drwx------  2 root root 4096 Jan 11 00:00 root</span><br><span class="line">drwxr-xr-x  1 root root 4096 Jan 30 01:39 run</span><br><span class="line">drwxr-xr-x  2 root root 4096 Jan 11 00:00 sbin</span><br><span class="line">drwxr-xr-x  2 root root 4096 Jan 11 00:00 srv</span><br><span class="line">dr-xr-xr-x 13 root root    0 Jan 30 01:39 sys</span><br><span class="line">drwxrwxrwt  1 root root 4096 Jan 12 10:17 tmp</span><br><span class="line">drwxr-xr-x  1 root root 4096 Jan 11 00:00 usr</span><br><span class="line">drwxr-xr-x  1 root root 4096 Jan 11 00:00 var</span><br><span class="line">root@99a009bbe1f8:/<span class="comment"># </span></span><br></pre></td></tr></table></figure><p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 <code>docker exec</code> 的原因。</p><h2 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h2><p>仓库（<code>Repository</code>）是集中存放镜像的地方。</p><p>一个容易混淆的概念是注册服务器（<code>Registry</code>）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 <code>dl.dockerpool.com/ubuntu</code> 来说，<code>dl.dockerpool.com</code> 是注册服务器地址，<code>ubuntu</code> 是仓库名。</p><h3 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h3><p>目前 Docker 官方维护了一个公共仓库 <a href="https://hub.docker.com/">Docker Hub</a>，其中已经包括了数量超过 15,000 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现</p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>你可以在 <a href="https://cloud.docker.com/">https://cloud.docker.com</a> 免费注册一个 Docker 账号</p><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>可以通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p><p>你可以通过 <code>docker logout</code> 退出登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@VM-0-11-centos myip]<span class="comment"># docker login</span></span><br><span class="line">Login with your Docker ID to push and pull images from Docker Hub. If you don<span class="string">&#x27;t have a Docker ID, head over to https://hub.docker.com to create one.</span></span><br><span class="line"><span class="string">Username: kesenhuang</span></span><br><span class="line"><span class="string">Password: </span></span><br><span class="line"><span class="string">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span></span><br><span class="line"><span class="string">Configure a credential helper to remove this warning. See</span></span><br><span class="line"><span class="string">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Login Succeeded</span></span><br></pre></td></tr></table></figure><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos myip]<span class="comment"># docker search centos</span></span><br><span class="line">NAME                                            DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">centos                                          The official build of CentOS.                   465       [OK]</span><br><span class="line">tianon/centos                                   CentOS 5 and 6, created using rinse instea...   28</span><br><span class="line">blalor/centos                                   Bare-bones base CentOS 6.5 image                6                    [OK]</span><br><span class="line">saltstack/centos-6-minimal                                                                      6                    [OK]</span><br><span class="line">tutum/centos-6.4                                DEPRECATED. Use tutum/centos:6.4 instead. ...   5                    [OK]</span><br></pre></td></tr></table></figure><p>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建、是否自动创建。</p><p>官方的镜像说明是官方项目组创建和维护的，automated 资源允许用户验证镜像的来源和内容。</p><p>根据是否是官方提供，可将镜像资源分为两类。</p><p>一种是类似 <code>centos</code> 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。</p><p>还有一种类型，比如 <code>tianon/centos</code> 镜像，它是由 Docker 的用户创建并维护的，往往带有用户名称前缀。可以通过前缀 <code>username/</code> 来指定使用某个用户提供的镜像，比如 tianon 用户。</p><p>另外，在查找的时候通过 <code>--filter=stars=N</code> 参数可以指定仅显示收藏数量为 <code>N</code> 以上的镜像。</p><h3 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h3><p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos myip]<span class="comment"># docker tag ubuntu:16.04  kesenhuang/ubuntu:16.04</span></span><br><span class="line">[root@VM-0-11-centos myip]<span class="comment"># docker push kesenhuang/ubuntu</span></span><br><span class="line">The push refers to repository [docker.io/kesenhuang/ubuntu]</span><br><span class="line">1a1a19626b20: Mounted from library/ubuntu </span><br><span class="line">5b7dc8292d9b: Mounted from library/ubuntu </span><br><span class="line">bbc674332e2e: Mounted from library/ubuntu </span><br><span class="line">da2785b7bb16: Mounted from library/ubuntu </span><br><span class="line">16.04: digest: sha256:85882f461cf3db2c743d8b17fdba79e522bc33af182f14bc7b6d45b6adb9adcf size: 1150</span><br></pre></td></tr></table></figure><h3 id="Docker-私有仓库"><a href="#Docker-私有仓库" class="headerlink" title="Docker 私有仓库"></a>Docker 私有仓库</h3><p>有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。</p><p>本节介绍如何使用本地仓库。</p><p><a href="https://docs.docker.com/registry/"><code>docker-registry</code></a> 是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 <a href="https://github.com/docker/distribution"><code>docker-registry</code></a> v2.x 版本。</p><h4 id="安装运行-docker-registry"><a href="#安装运行-docker-registry" class="headerlink" title="安装运行 docker-registry"></a>安装运行 docker-registry</h4><h4 id="容器运行"><a href="#容器运行" class="headerlink" title="容器运行"></a>容器运行</h4><p>你可以通过获取官方 <code>registry</code> 镜像来运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --restart=always --name registry registry</span><br></pre></td></tr></table></figure><p>这将使用官方的 <code>registry</code> 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code> 目录下。你可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 <code>/opt/data/registry</code> 目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos ~]<span class="comment"># docker run -d \</span></span><br><span class="line">&gt;     -p 5000:5000 \</span><br><span class="line">&gt;     -v /opt/data/registry:/var/lib/registry \</span><br><span class="line">&gt;     registry</span><br></pre></td></tr></table></figure><h4 id="在私有仓库上传、搜索、下载镜像"><a href="#在私有仓库上传、搜索、下载镜像" class="headerlink" title="在私有仓库上传、搜索、下载镜像"></a>在私有仓库上传、搜索、下载镜像</h4><p>创建好私有仓库之后，就可以使用 <code>docker tag</code> 来标记一个镜像，然后推送它到仓库。例如私有仓库地址为 <code>127.0.0.1:5000</code>。</p><p>先在本机查看已有的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p>使用 <code>docker tag</code> 将 <code>ubuntu:latest</code> 这个镜像标记为 <code>127.0.0.1:5000/ubuntu:latest</code>。</p><p>格式为 <code>docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos ~]<span class="comment"># docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:lates</span></span><br></pre></td></tr></table></figure><p>使用 <code>docker push</code> 上传标记的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos ~]<span class="comment"># docker push 127.0.0.1:5000/ubuntu:latest </span></span><br><span class="line">The push refers to repository [127.0.0.1:5000/ubuntu]</span><br><span class="line">f6253634dc78: Pushed </span><br><span class="line">9069f84dbbe9: Pushed </span><br><span class="line">bacd3af13903: Pushed </span><br><span class="line">latest: digest: sha256:4e4bc990609ed865e07afc8427c30ffdddca5153fd4e82c20d8f0783a291e241 size: 943</span><br></pre></td></tr></table></figure><p>用 <code>curl</code> 查看仓库中的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos ~]<span class="comment"># curl 127.0.0.1:5000/v2/_catalog</span></span><br><span class="line">&#123;<span class="string">&quot;repositories&quot;</span>:[<span class="string">&quot;ubuntu&quot;</span>]&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到 <code>&#123;&quot;repositories&quot;:[&quot;ubuntu&quot;]&#125;</code>，表明镜像已经被成功上传了。</p><p>先删除已有镜像，再尝试从私有仓库中下载这个镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-11-centos ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">myip                    latest              5046817304ae        24 hours ago        147MB</span><br><span class="line">nginx                   v3                  d8429783e126        25 hours ago        133MB</span><br><span class="line">ubuntu-with-vim         latest              08d108b45e78        2 days ago          514MB</span><br><span class="line">ubuntu-with-vi          latest              126c81439955        2 days ago          131MB</span><br><span class="line">nginx                   latest              f6d0b4767a6c        2 weeks ago         133MB</span><br><span class="line">registry                latest              678dfa38fcfa        6 weeks ago         26.2MB</span><br><span class="line">kesenhuang/ubuntu       16.04               9499db781771        2 months ago        131MB</span><br><span class="line">ubuntu                  16.04               9499db781771        2 months ago        131MB</span><br><span class="line">127.0.0.1:5000/ubuntu   latest              f643c72bc252        2 months ago        72.9MB</span><br><span class="line"></span><br><span class="line">[root@VM-0-11-centos ~]<span class="comment"># docker image  rm 127.0.0.1:5000/ubuntu:latest</span></span><br><span class="line">Untagged: 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">Untagged: 127.0.0.1:5000/ubuntu@sha256:4e4bc990609ed865e07afc8427c30ffdddca5153fd4e82c20d8f0783a291e241</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@VM-0-11-centos ~]<span class="comment"># docker pull 127.0.0.1:5000/ubuntu:latest</span></span><br><span class="line">latest: Pulling from ubuntu</span><br><span class="line">Digest: sha256:4e4bc990609ed865e07afc8427c30ffdddca5153fd4e82c20d8f0783a291e241</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">127.0.0.1:5000/ubuntu:latest</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>如果你不想使用 <code>127.0.0.1:5000</code> 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 <code>192.168.199.100:5000</code> 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。</p><p>这是因为 Docker 默认不允许非 <code>HTTPS</code> 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 <code>HTTPS</code> 访问的私有仓库。</p><h4 id="Ubuntu-14-04-Debian-7-Wheezy"><a href="#Ubuntu-14-04-Debian-7-Wheezy" class="headerlink" title="Ubuntu 14.04, Debian 7 Wheezy"></a>Ubuntu 14.04, Debian 7 Wheezy</h4><p>对于使用 <code>upstart</code> 的系统而言，编辑 <code>/etc/default/docker</code> 文件，在其中的 <code>DOCKER_OPTS</code> 中增加如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS=<span class="string">&quot;--registry-mirror=https://registry.docker-cn.com --insecure-registries=192.168.199.100:5000&quot;</span></span><br></pre></td></tr></table></figure><p>重新启动服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service docker restart</span><br></pre></td></tr></table></figure><h4 id="Ubuntu-16-04-Debian-8-centos-7"><a href="#Ubuntu-16-04-Debian-8-centos-7" class="headerlink" title="Ubuntu 16.04+, Debian 8+, centos 7"></a>Ubuntu 16.04+, Debian 8+, centos 7</h4><p>对于使用 <code>systemd</code> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://registry.docker-cn.com&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;192.168.199.100:5000&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：该文件必须符合 <code>json</code> 规范，否则 Docker 将不能启动。</p></blockquote><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>对于 Docker for Windows 、 Docker for Mac 在设置中编辑 <code>daemon.json</code> 增加和上边一样的字符串即可。/</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;容器生态系统&quot;&gt;&lt;a href=&quot;#容器生态系统&quot; class=&quot;headerlink&quot; title=&quot;容器生态系统&quot;&gt;&lt;/a&gt;容器生态系统&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/24/6NjQbWXVq3KD8n</summary>
      
    
    
    
    <category term="云技术" scheme="http://example.com/categories/%E4%BA%91%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="docker" scheme="http://example.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>linux</title>
    <link href="http://example.com/system/linux/"/>
    <id>http://example.com/system/linux/</id>
    <published>2021-01-18T14:08:51.000Z</published>
    <updated>2021-01-31T12:38:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Linux-简介"><a href="#Linux-简介" class="headerlink" title="Linux 简介"></a>Linux 简介</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>定义：Linux 是一种自由和开放源码的类 UNIX 操作系统，使用 Linux 内核。</p><p>主要发行版：</p><ol><li><p>RedHat </p><p>​         -  Red Hat Enterprise Linux 收费</p><p>​            - Centos 免费，国内互联网商用</p></li><li><p>Ubuntu ：免费，由众多黑客维护</p></li><li><p>Suse：专业的操作系统，易用的YaST软件包管理系统</p></li></ol><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ol><li><p>安装虚拟机</p></li><li><p>创建虚拟空间，网络连接方式</p><blockquote><p> 桥接</p></blockquote></li></ol><p> 桥接网络是指本地物理网卡和虚拟网卡通过VMnet0虚拟交换机进行桥接，物理网卡和虚拟网卡在拓扑图上处于同等地位，那么物理网卡和虚拟网卡就相当于处于同一个网段，虚拟交换机就相当于一台现实网络中的交换机,所以两个网卡的IP地址也要设置为同一网段。</p><p>​                NAT</p><p>NAT模式中，就是让虚拟机借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。</p><p>  NAT模式中，虚拟机的网卡和物理网卡的网络，不在同一个网络，虚拟机的网卡，是在vmware提供的一个虚拟网络。</p><p>  NAT和桥接的比较:</p><p>  (1) NAT模式和桥接模式虚拟机都可以上外网。</p><p>  (2) 由于NAT的网络在vmware提供的一个虚拟网络里，所以局域网其他主机是无法访问虚拟机的，而宿主机可以访问虚拟机，虚拟机可以访问局域网的所有主机，因为真实的局域网相对于NAT的虚拟网络，就是NAT的虚拟网络的外网，不懂的人可以查查NAT的相关知识。</p><p>  (3) 桥接模式下，多个虚拟机之间可以互相访问；NAT模式下，多个虚拟机之间也可以相互访问。</p><p>  如果你建一个虚拟机，只是给自己用，不需要给局域网其他人用，那么可以选择NAT，毕竟NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的，只要虚拟机的网路配置是DHCP，那么你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可，就可以让虚拟机联网了。</p><p> 例如你想建多个虚拟机集群，作为测试使用，而宿主机可能是一个笔记本，ip不固定。这种应用场景，我们需要采用nat模式了，但是我们要考虑一个问题，虚拟机之间是需要互访的，默认采用dhcp，虚拟机的ip每次重启，ip都是不固定的，所以我们需要手工设置虚拟机的ip地址。</p><p> 但是我们对虚拟机网卡所在的虚拟网络的信息还一无所知，例如虚拟机网络的路由地址，子网掩码，所以我们需要先查下nat虚拟网络的信息。</p><p> 使用vmware,在Edit-&gt;Virtual Network Editor中配置好虚拟网络信息后看到下图所示，注意VMnet8，VMnet8相当于是本机的一个路由，虚拟机设置NAT后就通过这个路由进行上网的，可以查看其网络地址，路由地址，子网掩码。</p><p> 选择VMnet8-&gt;NAT设置,可以看到子网ip显示为192.168.233.0，子网掩码是255.255.255.0，那路由地址呢，其实就是网关IP了，都是同个东西，这里是192.168.233.2。</p><p> 接下来就好办了，在对应的虚拟机设置好ip，子网掩码，路由地址就可以上外网了，至于dns可以设置为8.8.8.8.</p><blockquote><p>Host-Only</p></blockquote><p>在Host-Only模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实Host-Only网络和NAT网络很相似，不同的地方就是Host-Only网络没有NAT服务，所以虚拟网络不能连接到Internet。主机和虚拟机之间的通信是通过VMware Network Adepter VMnet1虚拟网卡来实现的。</p><p>　　Host-Only的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。这个功能或许对普通用户来说没有多大意义，但大型服务商会常常利用这个功能。如果你想为VMnet1网段提供路由功能，那就需要使用RRAS，而不能使用XP或2000的ICS，因为ICS会把内网的IP地址改为192.168.0.1，但虚拟机是不会给VMnet1虚拟网卡分配这个地址的，那么主机和虚拟机之间就不能通信了。</p><ol><li><p>安装Centos</p><p>对分区的基本要求：至少有一个根（/） 分区，用于存放系统文件及程序，大小为5GB以上</p></li></ol><h3 id="Linux的基础知识"><a href="#Linux的基础知识" class="headerlink" title="Linux的基础知识"></a>Linux的基础知识</h3><h4 id="Linux系统的组成"><a href="#Linux系统的组成" class="headerlink" title="Linux系统的组成"></a>Linux系统的组成</h4><ol><li><strong>linux内核</strong>（linus 团队管理）</li><li><strong>shell</strong>：用户与内核交互的接口</li><li>*文件系统**：ext3、ext4等。windows 有 fat32 、ntfs</li><li><strong>第三方应用软件</strong></li></ol><h4 id="Shell的基本知识"><a href="#Shell的基本知识" class="headerlink" title="Shell的基本知识"></a>Shell的基本知识</h4><blockquote><p>Shell是系统的用户界面，提供了<strong>用户与内核进行交互操作的一种接口</strong>(命令解释器)</p></blockquote><p>shell可以执行：</p><ul><li><strong>内部命令</strong></li><li><strong>应用程序</strong></li><li><strong>shell脚本</strong></li></ul><h2 id="Linux-远程控制管理"><a href="#Linux-远程控制管理" class="headerlink" title="Linux 远程控制管理"></a>Linux 远程控制管理</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>传统的网络服务程序，FTP、POP、telnet 本质上都是不安全的，因为它们在网络上通过明文传送口令和数据，这些数据非常容易被截获。SSH 叫做 <code>Secure Shell</code>。通过 SSH，可以把传输数据进行加密，预防攻击，传输的数据进行了压缩，可以加快传输速度。</p><h3 id="OpenSSH"><a href="#OpenSSH" class="headerlink" title="OpenSSH"></a>OpenSSH</h3><p>SSH 是芬兰一家公司开发。但是受到版权和加密算法限制，现在很多人都使用 OpenSSH。OpenSSH 是 SSH 的替代软件，免费。</p><p>OpenSSH 由客户端和服务端组成。</p><ul><li>基于口令的安全验证：知道服务器的帐号密码即可远程登录，口令和数据在传输过程中都会被加密。</li><li>基于密钥的安全验证：此时需要在创建一对密钥，把公有密钥放到远程服务器上自己的宿主目录中，而私有密钥则由自己保存</li></ul><h2 id="Linux-的目录结构"><a href="#Linux-的目录结构" class="headerlink" title="Linux 的目录结构"></a>Linux 的目录结构</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><img src="https://i.loli.net/2021/01/18/nWAuUbQj7rdBkOT.png" alt="linux文件目录结构"></p><table><thead><tr><th align="left">目录</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">bin</td><td align="left">存放二进制可执行文件(ls,cat,mkdir等)</td></tr><tr><td align="left">boot</td><td align="left">存放用于系统引导时使用的各种文件</td></tr><tr><td align="left">dev</td><td align="left">用于存放设备文件</td></tr><tr><td align="left">etc</td><td align="left">存放系统配置文件</td></tr><tr><td align="left">home</td><td align="left">存放所有用户文件的根目录</td></tr><tr><td align="left">lib</td><td align="left">存放跟文件系统中的程序运行所需要的共享库及内核模块</td></tr><tr><td align="left">mnt</td><td align="left">系统管理员安装临时文件系统的安装点</td></tr><tr><td align="left">opt</td><td align="left">额外安装的可选应用程序包所放置的位置</td></tr><tr><td align="left">proc</td><td align="left">虚拟文件系统，存放当前内存的映射</td></tr><tr><td align="left">root</td><td align="left">超级用户目录</td></tr><tr><td align="left">sbin</td><td align="left">存放二进制可执行文件，只有root才能访问</td></tr><tr><td align="left">tmp</td><td align="left">用于存放各种临时文件</td></tr><tr><td align="left">usr</td><td align="left">用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录</td></tr><tr><td align="left">var</td><td align="left">用于存放运行时需要改变数据的文件</td></tr></tbody></table><h2 id="常用文件、目录操作命令"><a href="#常用文件、目录操作命令" class="headerlink" title="常用文件、目录操作命令"></a>常用文件、目录操作命令</h2><h3 id="命令表"><a href="#命令表" class="headerlink" title="命令表"></a>命令表</h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th><th align="left">语法</th><th align="left">参数</th><th align="left">参数说明</th></tr></thead><tbody><tr><td align="left">ls</td><td align="left">显示文件和目录列表</td><td align="left">ls [-alrtAFR] [name…]</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">-l</td><td align="left">列出文件的详细信息</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">-a</td><td align="left">列出当前目录所有文件，包含隐藏文件</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">-h</td><td align="left">显示大小，便于查看（例如G、M、K）</td></tr><tr><td align="left">mkdir</td><td align="left">创建目录</td><td align="left">mkdir [-p] dirName</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">-p</td><td align="left">父目录不存在情况下先生成父目录</td></tr><tr><td align="left">cd</td><td align="left">切换目录</td><td align="left">cd [dirName]</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">touch</td><td align="left">生成一个空文件</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">echo</td><td align="left">生成一个带内容文件</td><td align="left">echo abcd &gt; 1.txt，echo 1234 &gt;&gt; 1.txt</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">cat</td><td align="left">显示文本文件内容</td><td align="left">cat [-AbeEnstTuv] [–help] [–version] fileName</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">cp</td><td align="left">复制文件或目录</td><td align="left">cp [options] source dest</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">-p</td><td align="left">复制的文件保持原有文件的修改时间</td></tr><tr><td align="left">rm</td><td align="left">删除文件</td><td align="left">rm [options] name…</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">-f</td><td align="left">强制删除文件或目录</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">-r</td><td align="left">同时删除该目录下的所有文件</td></tr><tr><td align="left">mv</td><td align="left">移动文件或目录</td><td align="left">mv [options] source dest</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">mv oldNameFile new NameFile</td><td align="left">重命名</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">mv fileName /targetFolder</td><td align="left">移动文件</td></tr><tr><td align="left">find</td><td align="left">在文件系统中查找指定的文件</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">-name</td><td align="left">文件名</td></tr><tr><td align="left">grep</td><td align="left">在指定的文本文件中查找指定的字符串</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">tree</td><td align="left">用于以树状图列出目录的内容</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">pwd</td><td align="left">显示当前工作目录</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">ln</td><td align="left">建立软链接</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">more</td><td align="left">分页显示文本文件内容</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">空格键</td><td align="left">向下滚动一屏</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">Crtl + B</td><td align="left">返回上一屏</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">Enter</td><td align="left">向下n行，需要定义，默认一行</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">q</td><td align="left">退出more</td></tr><tr><td align="left">head</td><td align="left">显示文件开头内容</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">tail</td><td align="left">显示文件结尾内容</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">-f</td><td align="left">跟踪输出</td></tr></tbody></table><h3 id="TIP"><a href="#TIP" class="headerlink" title="TIP"></a>TIP</h3><ul><li><code>. </code>表示当前目录</li><li><code>..</code> 表示当前目录的上一级目录（父目录）</li><li><code>-</code>表示用 cd 命令切换目录<strong>前</strong>所在的目录</li><li><code>~</code> 表示<strong>用户主目录</strong>的绝对路径名</li><li><code>管道命令 |</code> ：将前面的结果给后面的命令，例如：<code>ls -la | wc </code>，将ls的结果加油wc命令来统计字数</li><li><code>重定向 &gt; 是覆盖模式，&gt;&gt; 是追加模式</code></li></ul><p><strong>绝对路径：</strong></p><ul><li>以斜线（/）开头 ，描述到文件位置的<strong>完整说明</strong> ，任何时候你想指定文件名的时候都可以使用</li></ul><p><strong>相对路径 ：</strong></p><ul><li>不以斜线（/）开头 ，指定<strong>相对于你的当前工作目录而言的位置</strong> ，可以被用作指定文件名的简捷方式</li></ul><h2 id="常用监控系统状态命令"><a href="#常用监控系统状态命令" class="headerlink" title="常用监控系统状态命令"></a>常用监控系统状态命令</h2><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">stat</td><td align="left">显示指定文件的相关信息,比ls命令显示内容更多</td></tr><tr><td align="left">who</td><td align="left">显示在线登录用户</td></tr><tr><td align="left">hostname</td><td align="left">显示主机名称</td></tr><tr><td align="left">uname</td><td align="left">显示系统信息</td></tr><tr><td align="left">top</td><td align="left">显示当前系统中耗费资源最多的进程</td></tr><tr><td align="left">ps</td><td align="left">显示瞬间的进程状态</td></tr><tr><td align="left">du</td><td align="left">显示指定的文件（目录）已使用的磁盘空间的总量</td></tr><tr><td align="left">df</td><td align="left">显示文件系统磁盘空间的使用情况</td></tr><tr><td align="left">free</td><td align="left">显示当前内存和交换空间的使用情况</td></tr><tr><td align="left">ifconfig</td><td align="left">显示网络接口信息</td></tr><tr><td align="left">ping</td><td align="left">测试网络的连通性</td></tr><tr><td align="left">netstat</td><td align="left">显示网络状态信息</td></tr><tr><td align="left">clear</td><td align="left">清屏</td></tr><tr><td align="left">kill</td><td align="left">杀死一个进程</td></tr></tbody></table><h3 id="显示进程信息"><a href="#显示进程信息" class="headerlink" title="显示进程信息"></a>显示进程信息</h3><table><thead><tr><th>操作</th><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>参数</td><td></td><td></td></tr><tr><td></td><td>-a</td><td>显示当前终端的所有进程信息</td></tr><tr><td></td><td>-u</td><td>以用户的格式显示进程信息</td></tr><tr><td></td><td>-x</td><td>显示后台进程运行的参数</td></tr><tr><td></td><td>-e</td><td>显示所有进程</td></tr><tr><td></td><td>-f</td><td>全格式</td></tr><tr><td>例子</td><td></td><td></td></tr><tr><td></td><td>aux</td><td>显示当前进程状态</td></tr><tr><td></td><td>ef</td><td>可以显示父进程ID，</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h4 id="ps-aux-：显示当前进程状态"><a href="#ps-aux-：显示当前进程状态" class="headerlink" title="ps -aux ：显示当前进程状态"></a>ps -aux ：显示当前进程状态</h4><ul><li>USER: 行程拥有者</li><li>PID: pid</li><li>%CPU: 占用的 CPU 使用率</li><li>%MEM: 占用的记忆体使用率</li><li>VSZ: 占用的虚拟记忆体大小</li><li>RSS: 占用的记忆体大小</li><li>TTY: 终端的次要装置号码 (minor device number of tty)</li><li>STAT: 该行程的状态:<ul><li>D: 无法中断的休眠状态 (通常 IO 的进程)</li><li>R: 正在执行中</li><li>S: 静止状态</li><li>T: 暂停执行</li><li>Z: 不存在但暂时无法消除</li><li>W: 没有足够的记忆体分页可分配</li><li>&lt;: 高优先序的行程</li><li>N: 低优先序的行程</li><li>L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)</li></ul></li><li>START: 行程开始时间</li><li>TIME: 执行的时间</li><li>COMMAND:所执行的指令</li></ul><h4 id="ps-ef"><a href="#ps-ef" class="headerlink" title="ps  -ef"></a>ps  -ef</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UID    PID PPID C STIME TTY     TIME CMD</span><br></pre></td></tr></table></figure><ul><li>UID:用户ID</li><li>PID：进程ID</li><li>PPID：父进程ID</li><li>C：CPU用户计算执行优先级的因子。数值越大，表明进程是CPU密集型运算，执行优先级会降低；数值越小，表明进程是I/O密集型运算，执行优先级会提高</li><li>STIME：进程启动的时间</li><li>TTY：完整的终端名称</li><li>TIME：CPU时间</li><li>CMD：启动进程所用的命名和参数</li></ul><h3 id="查看网络情况"><a href="#查看网络情况" class="headerlink" title="查看网络情况"></a>查看网络情况</h3><h4 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h4><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>-an</td><td>按一定顺序排列输出</td></tr><tr><td>-p</td><td>显示哪个进程在调用</td></tr><tr><td></td><td><code>一般用netstat -anp</code></td></tr></tbody></table><h2 id="开关机命令"><a href="#开关机命令" class="headerlink" title="开关机命令"></a>开关机命令</h2><p>shutdown 命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。</p><table><thead><tr><th align="left">命令</th><th align="left">语法</th><th align="left">参数</th><th align="left">参数说明</th></tr></thead><tbody><tr><td align="left">shutdown</td><td align="left">shutdown [-t seconds] [-rkhncfF] time [message]</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">-t seconds</td><td align="left">设定在几秒钟之后进行关机程序</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">-k</td><td align="left">并不会真的关机，只是将警告讯息传送给所有只用者</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">-r</td><td align="left">关机后重新开机（重启）</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">-h</td><td align="left">关机后停机</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">-n</td><td align="left">不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">-c</td><td align="left">取消目前已经进行中的关机动作</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">-f</td><td align="left">关机时，不做 fcsk 动作(检查 Linux 档系统)</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">-F</td><td align="left">关机时，强迫进行 fsck 动作</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">time</td><td align="left">设定关机的时间</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">message</td><td align="left">传送给所有使用者的警告讯息</td></tr></tbody></table><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><ul><li>reboot</li><li>shutdown  -r now</li></ul><h3 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h3><ul><li>shutdown -h nown</li></ul><h2 id="文件打包和压缩命令"><a href="#文件打包和压缩命令" class="headerlink" title="文件打包和压缩命令"></a>文件打包和压缩命令</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>xz</td><td>使用LZMA算法的高性能压缩/解压工具</td></tr><tr><td>gzip</td><td>流行的GUN gzip数据压缩/解压程序</td></tr><tr><td>bzip2</td><td>免费的，无专利的高性能数据压缩工具</td></tr><tr><td>zip/unzip</td><td>与WinZIP兼容的压缩/解压工具</td></tr><tr><td>rar</td><td>与WinRAR兼容的压缩/解压工具</td></tr><tr><td>7za</td><td>使用LZMA算法的高性能压缩/解压工具</td></tr><tr><td>tar</td><td>文件打包、归档工具</td></tr></tbody></table><h3 id="常用的压缩方式详解"><a href="#常用的压缩方式详解" class="headerlink" title="常用的压缩方式详解"></a>常用的压缩方式详解</h3><h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><table><thead><tr><th align="left">命令</th><th align="left">语法</th><th align="left">参数</th><th align="left">参数说明</th></tr></thead><tbody><tr><td align="left">tar</td><td align="left">tar [-cxzjvf] 压缩打包文档的名称 欲打包目录</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">-c</td><td align="left">建立一个归档文件的参数指令</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">-x</td><td align="left">解开一个归档文件的参数指令</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">-z</td><td align="left">是否需要用 gzip 压缩</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">-j</td><td align="left">是否需要用 bzip2 压缩</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">-v</td><td align="left">压缩的过程中显示文件</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">-f</td><td align="left">使用档名，在 f 之后要立即接档名</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">-tf</td><td align="left">查看归档文件里面的文件</td></tr></tbody></table><p><strong>例子：</strong></p><p>​    </p><ul><li>压缩文件夹：<code>tar -zcvf test.tar.gz /test/</code></li><li>打包多个文件  <code>tar -zcvf test.tar.gz  test1.txt test2.txt</code></li><li>解压文件夹到当前目录：<code>tar -zxvf test.tar.gz</code></li><li>解压到指定目录 <code>tar -zxvf test.tar.gz -C  /test/</code></li></ul><h4 id="gzip-gunzip"><a href="#gzip-gunzip" class="headerlink" title="gzip/gunzip"></a>gzip/gunzip</h4><table><thead><tr><th align="left">命令</th><th align="left">语法</th><th align="left">参数</th><th align="left">参数说明</th></tr></thead><tbody><tr><td align="left">gzip</td><td align="left">gzip [选项] 压缩（解压缩）的文件名</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">-d</td><td align="left">解压缩</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">-l</td><td align="left">对每个压缩文件，显示压缩文件的大小，未压缩文件的大小，压缩比，未压缩文件的名字</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">-v</td><td align="left">对每一个压缩和解压的文件，显示文件名和压缩比</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">-num</td><td align="left">用指定的数字num调整压缩的速度，-1或–fast表示最快压缩方法（低压缩比），-9或–best表示最慢压缩方法（高压缩比）。系统缺省值为6</td></tr><tr><td align="left">gunzip</td><td align="left">解压文件</td><td align="left"></td><td align="left"></td></tr></tbody></table><p>说明：压缩文件后缀为 gz</p><p>​                gzip对文件进行压缩后，不会保留原来的文件</p><h4 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h4><table><thead><tr><th align="left">命令</th><th align="left">语法</th><th align="left">参数</th><th align="left">参数说明</th></tr></thead><tbody><tr><td align="left">bzip2</td><td align="left">bzip2 [-cdz]</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">-d</td><td align="left">解压缩</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">-z</td><td align="left">压缩参数</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">-num</td><td align="left">用指定的数字num调整压缩的速度，-1或–fast表示最快压缩方法（低压缩比），-9或–best表示最慢压缩方法（高压缩比）。系统缺省值为6</td></tr></tbody></table><p>说明：压缩文件后缀为 bz2</p><h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><h3 id="vi-vim运行模式"><a href="#vi-vim运行模式" class="headerlink" title="vi/vim运行模式"></a>vi/vim运行模式</h3><ul><li>普通模式：等待编辑命令输入</li><li>编辑模式：普通模式下，输入 <code>i</code> 进入插入模式，插入文本信息</li><li>命令模式：在编辑模式下，输入 <code>:</code> 进行命令模式</li></ul><h4 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h4><table><thead><tr><th>操作</th><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>移动</td><td></td><td></td></tr><tr><td></td><td>G</td><td>移动到文档的最后一行</td></tr><tr><td></td><td>nG</td><td>n为数字，移动到这个文档的第n行。例如20G则会移动到这个文档的第20行</td></tr><tr><td></td><td>gg</td><td>移动到这个文档的第一行，相当于1G</td></tr><tr><td>翻页</td><td></td><td></td></tr><tr><td></td><td>Crtl+f</td><td>屏幕向下移动一页，相当于Page Down</td></tr><tr><td></td><td>Crtl+b</td><td>屏幕向上移动一页，相当于Page Up</td></tr><tr><td></td><td>Ctrl+d</td><td>屏幕向下移动半页</td></tr><tr><td></td><td>Ctrl+u</td><td>屏幕向上移动半页</td></tr><tr><td>搜索</td><td></td><td></td></tr><tr><td></td><td>/</td><td>向光标之 下寻找，例如/word，向下查找名称为word的字符串</td></tr><tr><td></td><td>?</td><td>向光标之 上寻找，例如?word，向上查找名称为word的字符串</td></tr><tr><td></td><td>n</td><td>命令行下/关键字，回车查找，输入n就是查找下一个</td></tr><tr><td></td><td>N</td><td>反向查找</td></tr><tr><td>删除</td><td></td><td></td></tr><tr><td></td><td>x</td><td>删除光标所在的字符</td></tr><tr><td></td><td>dd</td><td>删除游标所在的那一行（常用）</td></tr><tr><td></td><td>ndd</td><td>n为数字，删除光标所在的向下n行</td></tr><tr><td>复制</td><td></td><td></td></tr><tr><td></td><td>yy</td><td>复制游标所在的那一行</td></tr><tr><td></td><td>nyy</td><td>n为数字，复制光标所在的向下n行</td></tr><tr><td>粘贴</td><td></td><td></td></tr><tr><td></td><td>p</td><td>粘帖在下一行</td></tr><tr><td></td><td>P</td><td>P粘贴在前一行</td></tr><tr><td>取消</td><td></td><td></td></tr><tr><td></td><td>u</td><td>取消上一次编辑操作(undo)</td></tr></tbody></table><h4 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h4><p>编辑模式主要用于文本的编辑。该模式下用户输入的任何字符都被作为文件的内容保存起来，并在屏幕上显示出来。</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>i</td><td>在当前光标位置之前插入文本</td></tr><tr><td>I</td><td>在当前行的开头插入文本</td></tr><tr><td>a</td><td>在当前光标位置之后插入文本</td></tr><tr><td>A</td><td>在当前行的末尾插入文本</td></tr><tr><td>o</td><td>在当前位置下面创建一行</td></tr><tr><td>O</td><td>在当前位置上面创建一行</td></tr></tbody></table><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p>Normal 模式下，用户按冒号 <code>:</code>即可进入 Command 模式，此时 vim 会在显示窗口的最后一行 (屏幕的最后一行) 显示一个 “:” 作为 Command 模式的提示符，等待输入命令。</p><table><thead><tr><th>操作</th><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>存储、离开</td><td></td><td></td></tr><tr><td></td><td>:w</td><td>保存当前编辑文件，但并不退出</td></tr><tr><td></td><td>:w!</td><td>若属性为只读时，强制写入该文档。</td></tr><tr><td></td><td>:q</td><td>退出vi</td></tr><tr><td></td><td><code>:q!</code></td><td>不存盘强制退出</td></tr><tr><td></td><td><code>:wq</code></td><td>用于存盘退出</td></tr><tr><td></td><td>:wq!</td><td>强制存盘并退出</td></tr><tr><td></td><td>ZZ</td><td>用于存盘退出Vi</td></tr><tr><td></td><td>:w[filename]</td><td>另存文档</td></tr><tr><td>set 命令</td><td></td><td></td></tr><tr><td></td><td><code>:set ic</code></td><td>搜索时忽略大小写。</td></tr><tr><td></td><td>:set ai</td><td>设置自动缩进（自动对齐）。</td></tr><tr><td></td><td>:set noai</td><td>取消自动缩进（自动对齐）</td></tr><tr><td></td><td><code>:set nu</code></td><td>显示行号。</td></tr><tr><td></td><td><code>:set nonumber</code></td><td>在编辑文件不显示行号</td></tr><tr><td></td><td>:set sw</td><td>设置缩进的空格数，例如，将缩进空格数设置为4：:set sw=4。</td></tr><tr><td></td><td>:set ws</td><td>循环搜索：如果直到文件末尾也没有查找到指定字符，那么会回到开头继续查找。</td></tr><tr><td></td><td>:set wm</td><td>设置自动换行，例如，设置距离边际2个字符时换行：:set wm=2 。</td></tr></tbody></table><h2 id="Linux-用户和组管理"><a href="#Linux-用户和组管理" class="headerlink" title="Linux 用户和组管理"></a>Linux 用户和组管理</h2><p>Linux 操作系统是一个多用户操作系统，它允许多用户同时登录到系统上并使用资源。系统会根据账户来区分每个用户的文件，进程，任务和工作环境，使得每个用户工作都不受干扰。</p><p>任何一个使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统</p><p>linux的用户需要至少属于一个组</p><h3 id="用户和组管理相关命令"><a href="#用户和组管理相关命令" class="headerlink" title="用户和组管理相关命令"></a>用户和组管理相关命令</h3><h4 id="用户管理常用命令"><a href="#用户管理常用命令" class="headerlink" title="用户管理常用命令"></a>用户管理常用命令</h4><table><thead><tr><th>操作</th><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>添加用户</td><td>useradd [选项] 用户名</td><td></td></tr><tr><td></td><td>useradd -u (UID号)</td><td></td></tr><tr><td></td><td>useradd -p 口令 用户名</td><td></td></tr><tr><td></td><td>useradd -g 用户组 用户名</td><td></td></tr><tr><td></td><td>useradd -s (SHELL)</td><td></td></tr><tr><td></td><td>useradd -d (用户目录)</td><td></td></tr><tr><td>编辑用户</td><td></td><td></td></tr><tr><td></td><td>usermod -u (新UID)</td><td></td></tr><tr><td></td><td>usermod -d (用户目录)</td><td></td></tr><tr><td></td><td>usermod -g (组名)</td><td></td></tr><tr><td></td><td>usermod -s (SHELL)</td><td></td></tr><tr><td></td><td>usermod -p (新口令)</td><td></td></tr><tr><td></td><td>usermod -l (新登录名)</td><td></td></tr><tr><td></td><td>usermod -L (锁定用户账号密码)</td><td></td></tr><tr><td></td><td>usermod -U (解锁用户账号)</td><td></td></tr><tr><td>删除用户</td><td>userdel 用户名 (删除用户账号)</td><td></td></tr><tr><td></td><td>userdel -r 删除账号时同时删除目录</td><td></td></tr><tr><td>切换用户</td><td>su  -切换用户名</td><td></td></tr></tbody></table><h4 id="口令维护"><a href="#口令维护" class="headerlink" title="口令维护"></a>口令维护</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">passwd 用户账户名 (设置用户口令)</span><br><span class="line">passwd -l 用户账户名 (锁定用户账户)</span><br><span class="line">passwd -u 用户账户名 (解锁用户账户)</span><br><span class="line">passwd -d 用户账户名 (删除账户口令)</span><br><span class="line">gpasswd -a 用户账户名 组账户名 (将指定用户添加到指定组)</span><br><span class="line">gpasswd -d 用户账户名 组账户名 (将用户从指定组中删除)</span><br><span class="line">gpasswd -A 用户账户名 组账户名 (将用户指定为组的管理员)</span><br></pre></td></tr></table></figure><h4 id="组账户维护"><a href="#组账户维护" class="headerlink" title="组账户维护"></a>组账户维护</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">groupadd 组账户名 (创建新组)</span><br><span class="line">groupadd -g 指定组GID</span><br><span class="line">groupmod -g 更改组的GID</span><br><span class="line">groupmod -n 更改组账户名</span><br><span class="line">groupdel 组账户名 (删除指定组账户)</span><br></pre></td></tr></table></figure><h4 id="用户和组状态"><a href="#用户和组状态" class="headerlink" title="用户和组状态"></a>用户和组状态</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">su 用户名(切换用户账户)</span><br><span class="line">id 用户名(显示用户的UID，GID)</span><br><span class="line">whoami (显示当前用户名称)</span><br><span class="line">groups (显示用户所属组)</span><br></pre></td></tr></table></figure><h3 id="账户系统文件说明"><a href="#账户系统文件说明" class="headerlink" title="账户系统文件说明"></a>账户系统文件说明</h3><h4 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h4><p>每一行代表一个账号，众多账号是系统正常运行所必须的，例如 bin，nobody 每行定义一个用户账户，此文件对所有用户可读。每行账户包含如下信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure><ul><li><strong>用户名：</strong> 就是账号，用来对应 UID，root UID 是 0。</li><li><strong>口令：</strong> 密码，早期 UNIX 系统密码存在此字段，由于此文件所有用户都可以读取，密码容易泄露，后来这个字段数据就存放到 /etc/shadow 中，这里只能看到 X。</li><li><strong>用户标示号（UID）：</strong> 系统内唯一，root 用户的 UID 为 0，普通用户从 1000 开始，1-999 是系统的标准账户，500-65536 是可登陆账号。</li><li><strong>组标示号（GID）：</strong> 与 /etc/group 相关用来规定组名和 GID 相对应。</li><li><strong>注释：</strong> 注释账号</li><li><strong>宿主目录（主文件夹）：</strong> 用户登录系统后所进入的目录 root 在 /root/itcast</li><li><strong>命令解释器（shell）：</strong> 指定该用户使用的 shell ，默认的是 /bin/bash</li></ul><h4 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h4><p>为了增加系统的安全性，用户口令通常用 shadow passwords 保护。只有 root 可读。每行包含如下信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:$6$Reu571.V$Ci/kd.OTzaSGU.TagZ5KjYx2MLzQv2IkZ24E1.yeTT3Pp4o/yniTjus/rRaJ92Z18MVy6suf1W5uxxurqssel.:17465:0:99999:7:::</span><br></pre></td></tr></table></figure><ul><li><p><strong>账号名称：</strong> 需要和 /etc/passwd 一致。</p></li><li><p>密码：</p><p>经过加密，虽然加密，但不表示不会被破解，该文件默认权限如下：</p><ul><li>-rw——- 1 root root 1560 Oct 26 17:20 passwd-</li><li>只有root能都读写</li></ul></li><li><p><strong>最近修改密码日期：</strong> 从1970-1-1起，到用户最后一次更改口令的天数</p></li><li><p><strong>密码最小时间间隔：</strong> 从1970-1-1起，到用户可以更改口令的天数</p></li><li><p><strong>密码最大时间间隔：</strong> 从1970-1-1起，必须更改的口令天数</p></li><li><p><strong>密码到期警告时间：</strong> 在口令过期之前几天通知</p></li><li><p><strong>密码到期后账号宽限时间</strong></p></li><li><p><strong>密码到期禁用账户时间：</strong> 在用户口令过期后到禁用账户的天数</p></li><li><p><strong>保留</strong></p></li></ul><h4 id="etc-group"><a href="#etc-group" class="headerlink" title="/etc/group"></a>/etc/group</h4><p>用户组的配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:</span><br></pre></td></tr></table></figure><ul><li><strong>用户组名称</strong></li><li><strong>用户组密码：</strong> 给用户组管理员使用，通常不用</li><li><strong>GID：</strong> 用户组的ID</li><li><strong>此用户支持的账号名称：</strong> 一个账号可以加入多个用户组，例如想要 itcast 加入 root 这个用户组，将该账号填入该字段即可 root❌0:root, icast 将用户进行分组是 Linux 对用户进行管理及控制访问权限的一种手段。一个中可以有多个用户，一个用户可以同时属于多个组。该文件对所有用户可读。</li></ul><h4 id="etc-gshadow"><a href="#etc-gshadow" class="headerlink" title="/etc/gshadow"></a>/etc/gshadow</h4><p>该文件用户定义用户组口令，组管理员等信息只有root用户可读。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:\*::</span><br></pre></td></tr></table></figure><ul><li><strong>用户组名</strong></li><li><strong>密码列</strong></li><li><strong>用户组管理员的账号</strong></li><li><strong>用户组所属账号</strong></li></ul><h2 id="Linux-文件权限管理"><a href="#Linux-文件权限管理" class="headerlink" title="Linux 文件权限管理"></a>Linux 文件权限管理</h2><h3 id="查看文件和目录的权限"><a href="#查看文件和目录的权限" class="headerlink" title="查看文件和目录的权限"></a>查看文件和目录的权限</h3><p>ls –al<code>使用 ls 不带参数只显示文件名称，通过</code>ls –al` 可以显示文件或者目录的权限信息。</p><p><code>ls -l 文件名</code> 显示信息包括：文件类型 (<code>d</code> 目录，<code>-</code> 普通文件，<code>l</code> 链接文件)，文件权限，文件的用户，文件的所属组，文件的大小，文件的创建时间，文件的名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 lusifer lusifer 675 Oct 26 17:20 .profile</span><br></pre></td></tr></table></figure><ul><li><code>-</code>：普通文件</li><li><code>rw-</code>：说明用户 lusifer 有读写权限，没有运行权限</li><li><code>r--</code>：表示用户组 lusifer 只有读权限，没有写和运行的权限</li><li><code>r--</code>：其他用户只有读权限，没有写权限和运行的权限</li></ul><table><thead><tr><th align="left">-rw-r–r–</th><th align="left">1</th><th align="left">lusifer</th><th align="left">lusifer</th><th align="left">675</th><th align="left">Oct 26 17:20</th><th align="left">.profile</th></tr></thead><tbody><tr><td align="left">文档类型及权限</td><td align="left">连接数</td><td align="left">文档所属用户</td><td align="left">文档所属组</td><td align="left">文档大小</td><td align="left">文档最后被修改日期</td><td align="left">文档名称</td></tr></tbody></table><table><thead><tr><th align="left">-</th><th align="left">rw-</th><th align="left">r–</th><th align="left">r–</th></tr></thead><tbody><tr><td align="left">文档类型</td><td align="left">文档所有者权限（user）</td><td align="left">文档所属用户组权限（group）</td><td align="left">其他用户权限（other）</td></tr></tbody></table><h4 id="文档类型"><a href="#文档类型" class="headerlink" title="文档类型"></a>文档类型</h4><ul><li><code>d</code> 表示目录</li><li><code>l</code> 表示软连接</li><li><code>–</code> 表示文件</li><li><code>c</code> 表示串行端口字符设备文件</li><li><code>b</code> 表示可供存储的块设备文件</li><li>余下的字符 3 个字符为一组。<code>r</code> 只读，<code>w</code> 可写，<code>x</code> 可执行，<code>-</code> 表示无此权限</li></ul><h4 id="连接数"><a href="#连接数" class="headerlink" title="连接数"></a>连接数</h4><p>指有多少个文件指向同一个索引节点</p><h4 id="文档所属用户和所属组"><a href="#文档所属用户和所属组" class="headerlink" title="文档所属用户和所属组"></a>文档所属用户和所属组</h4><p>就是文档属于哪个用户和用户组。文件所属用户和组是可以更改的</p><h4 id="文档大小"><a href="#文档大小" class="headerlink" title="文档大小"></a>文档大小</h4><p>默认是 bytes</p><h3 id="更改操作权限"><a href="#更改操作权限" class="headerlink" title="更改操作权限"></a>更改操作权限</h3><h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h4><p>是 change owner 的意思，主要作用就是改变文件或者目录所有者，所有者包含用户和用户组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown [-R] 用户名称 文件或者目录</span><br><span class="line">chown [-R] 用户名称 用户组名称 文件或目录</span><br></pre></td></tr></table></figure><p>-R：进行递归式的权限更改，将目录下的所有文件、子目录更新为指定用户组权限</p><h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h4><p>改变访问权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [who] [+ | - | =] [mode] 文件名</span><br></pre></td></tr></table></figure><p>表示操作对象可以是以下字母的一个或者组合</p><ul><li>u：用户 user</li><li>g：用户组 group</li><li>o：表示其他用户</li><li>a：表示所有用户是系统默认的</li></ul><h4 id="操作符号"><a href="#操作符号" class="headerlink" title="操作符号"></a>操作符号</h4><ul><li>+：表示添加某个权限</li><li>-：表示取消某个权限</li><li>=：赋予给定的权限，取消文档以前的所有权限</li></ul><h4 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h4><p>表示可执行的权限，可以是 r、w、x</p><h4 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h4><p>文件名可以使空格分开的文件列表</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u=rwx,g+r,o+r test.txt </span><br></pre></td></tr></table></figure><h3 id="数字设定法"><a href="#数字设定法" class="headerlink" title="数字设定法"></a>数字设定法</h3><p>数字设定法中数字表示的含义</p><ul><li>0 表示没有任何权限</li><li>1 表示有可执行权限 = <code>x</code></li><li>2 表示有可写权限 = <code>w</code></li><li>4 表示有可读权限 = <code>r</code></li></ul><p>也可以用数字来表示权限如 chmod 755 file_name</p><table><thead><tr><th align="left">r w x</th><th align="left">r – x</th><th align="left">r - x</th></tr></thead><tbody><tr><td align="left">4 2 1</td><td align="left">4 - 1</td><td align="left">4 - 1</td></tr><tr><td align="left">user</td><td align="left">group</td><td align="left">others</td></tr></tbody></table><p>若要 rwx 属性则 4+2+1=7</p><p>若要 rw- 属性则 4+2=6</p><p>若要 r-x 属性则 4+1=5</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 765 test.txt</span><br></pre></td></tr></table></figure><h2 id="Linux磁盘管理"><a href="#Linux磁盘管理" class="headerlink" title="Linux磁盘管理"></a>Linux磁盘管理</h2><p>Linux磁盘管理好坏直接关系到整个系统的性能问题。</p><p>Linux磁盘管理常用三个命令为df、du和fdisk。</p><ul><li>df：列出文件系统的整体磁盘使用量</li><li>du：检查磁盘空间使用量</li><li>fdisk：用于磁盘分区</li></ul><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p>df命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df [-ahikHTm] [目录或文件名]</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；</li><li>-k ：以 KBytes 的容量显示各文件系统；</li><li>-m ：以 MBytes 的容量显示各文件系统；</li><li>-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</li><li>-H ：以 M=1000K 取代 M=1024K 的进位方式；</li><li>-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；</li><li>-i ：不用硬盘容量，而以 inode 的数量来显示</li></ul><blockquote><p>推荐：  df  -h</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># df -h</span></span><br><span class="line">Filesystem            Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/hdc2             9.5G  3.7G  5.4G  41% /</span><br><span class="line">/dev/hdc3             4.8G  139M  4.4G   4% /home</span><br><span class="line">/dev/hdc1              99M   11M   83M  12% /boot</span><br><span class="line">tmpfs                 363M     0  363M   0% /dev/shm</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显示某个目录下的可用磁盘容量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># df -h /etc</span></span><br><span class="line">Filesystem            Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/hdc2             9.5G  3.7G  5.4G  41% /</span><br></pre></td></tr></table></figure><h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><p>Linux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的，这里介绍Linux du命令。</p><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du [-ahskm] 文件或目录名称</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。</li><li>-h ：以人们较易读的容量格式 (G/M) 显示；</li><li>-s ：列出总量而已，而不列出每个各别的目录占用容量；</li><li>-S ：不包括子目录下的总计，与 -s 有点差别。</li><li>-k ：以 KBytes 列出容量显示；</li><li>-m ：以 MBytes 列出容量显示；</li></ul><h3 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h3><p>fdisk 是 Linux 的磁盘分区表操作工具。</p><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk [-l] 装置名称</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-l ：输出后面接的装置所有的分区内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>出你系统中的根目录所在磁盘，并查阅该硬盘内的相关信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># df /            &lt;==注意：重点在找出磁盘文件名而已</span></span><br><span class="line">Filesystem           1K-blocks      Used Available Use% Mounted on</span><br><span class="line">/dev/hdc2              9920624   3823168   5585388  41% /</span><br><span class="line"></span><br><span class="line">[root@www ~]<span class="comment"># fdisk /dev/hdc  &lt;==仔细看，不要加上数字喔！</span></span><br><span class="line">The number of cylinders <span class="keyword">for</span> this disk is <span class="built_in">set</span> to 5005.</span><br><span class="line">There is nothing wrong with that, but this is larger than 1024,</span><br><span class="line">and could <span class="keyword">in</span> certain setups cause problems with:</span><br><span class="line">1) software that runs at boot time (e.g., old versions of LILO)</span><br><span class="line">2) booting and partitioning software from other OSs</span><br><span class="line">   (e.g., DOS FDISK, OS/2 FDISK)</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>):     &lt;==等待你的输入！</span><br></pre></td></tr></table></figure><p>输入 m 后，就会看到底下这些命令介绍</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): m   &lt;== 输入 m 后，就会看到底下这些命令介绍</span><br><span class="line">Command action</span><br><span class="line">   a   toggle a bootable flag</span><br><span class="line">   b   edit bsd disklabel</span><br><span class="line">   c   toggle the dos compatibility flag</span><br><span class="line">   d   delete a partition            &lt;==删除一个partition</span><br><span class="line">   l   list known partition types</span><br><span class="line">   m   <span class="built_in">print</span> this menu</span><br><span class="line">   n   add a new partition           &lt;==新增一个partition</span><br><span class="line">   o   create a new empty DOS partition table</span><br><span class="line">   p   <span class="built_in">print</span> the partition table     &lt;==在屏幕上显示分割表</span><br><span class="line">   q   quit without saving changes   &lt;==不储存离开fdisk程序</span><br><span class="line">   s   create a new empty Sun disklabel</span><br><span class="line">   t   change a partition<span class="string">&#x27;s system id</span></span><br><span class="line"><span class="string">   u   change display/entry units</span></span><br><span class="line"><span class="string">   v   verify the partition table</span></span><br><span class="line"><span class="string">   w   write table to disk and exit  &lt;==将刚刚的动作写入分割表</span></span><br><span class="line"><span class="string">   x   extra functionality (experts only)</span></span><br></pre></td></tr></table></figure><p>离开 fdisk 时按下 <code>q</code>，那么所有的动作都不会生效！相反的， 按下<code>w</code>就是动作生效的意思。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p  &lt;== 这里可以输出目前磁盘的状态</span><br><span class="line"></span><br><span class="line">Disk /dev/hdc: 41.1 GB, 41174138880 bytes        &lt;==这个磁盘的文件名与容量</span><br><span class="line">255 heads, 63 sectors/track, 5005 cylinders      &lt;==磁头、扇区与磁柱大小</span><br><span class="line">Units = cylinders of 16065 * 512 = 8225280 bytes &lt;==每个磁柱的大小</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/hdc1   *           1          13      104391   83  Linux</span><br><span class="line">/dev/hdc2              14        1288    10241437+  83  Linux</span><br><span class="line">/dev/hdc3            1289        1925     5116702+  83  Linux</span><br><span class="line">/dev/hdc4            1926        5005    24740100    5  Extended</span><br><span class="line">/dev/hdc5            1926        2052     1020096   82  Linux swap / Solaris</span><br><span class="line"><span class="comment"># 装置文件名 启动区否 开始磁柱    结束磁柱  1K大小容量 磁盘分区槽内的系统</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): q</span><br></pre></td></tr></table></figure><p>想要不储存离开吗？按下 q 就对了！不要随便按 w 啊！</p><p>使用 <code>p</code> 可以列出目前这颗磁盘的分割表信息，这个信息的上半部在显示整体磁盘的状态。</p><h3 id="磁盘格式化"><a href="#磁盘格式化" class="headerlink" title="磁盘格式化"></a>磁盘格式化</h3><p>磁盘分割完毕后自然就是要进行文件系统的格式化，格式化的命令非常的简单，使用 <code>mkfs</code>（make filesystem） 命令。</p><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs [-t 文件系统格式] 装置文件名</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-t ：可以接文件系统格式，例如 ext3, ext2, vfat 等(系统有支持才会生效)</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>查看 mkfs 支持的文件格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># mkfs[tab][tab]</span></span><br><span class="line">mkfs         mkfs.cramfs  mkfs.ext2    mkfs.ext3    mkfs.msdos   mkfs.vfat</span><br></pre></td></tr></table></figure><p>将分区 /dev/hdc6（可指定你自己的分区） 格式化为 ext3 文件系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># mkfs -t ext3 /dev/hdc6</span></span><br><span class="line">mke2fs 1.39 (29-May-2006)</span><br><span class="line">Filesystem label=                &lt;==这里指的是分割槽的名称(label)</span><br><span class="line">OS <span class="built_in">type</span>: Linux</span><br><span class="line">Block size=4096 (<span class="built_in">log</span>=2)          &lt;==block 的大小配置为 4K </span><br><span class="line">Fragment size=4096 (<span class="built_in">log</span>=2)</span><br><span class="line">251392 inodes, 502023 blocks     &lt;==由此配置决定的inode/block数量</span><br><span class="line">25101 blocks (5.00%) reserved <span class="keyword">for</span> the super user</span><br><span class="line">First data block=0</span><br><span class="line">Maximum filesystem blocks=515899392</span><br><span class="line">16 block groups</span><br><span class="line">32768 blocks per group, 32768 fragments per group</span><br><span class="line">15712 inodes per group</span><br><span class="line">Superblock backups stored on blocks:</span><br><span class="line">        32768, 98304, 163840, 229376, 294912</span><br><span class="line"></span><br><span class="line">Writing inode tables: <span class="keyword">done</span></span><br><span class="line">Creating journal (8192 blocks): <span class="keyword">done</span> &lt;==有日志记录</span><br><span class="line">Writing superblocks and filesystem accounting information: <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">This filesystem will be automatically checked every 34 mounts or</span><br><span class="line">180 days, whichever comes first.  Use tune2fs -c or -i to override.</span><br><span class="line"><span class="comment"># 这样就创建起来我们所需要的 Ext3 文件系统了！简单明了！</span></span><br></pre></td></tr></table></figure><h3 id="磁盘检验"><a href="#磁盘检验" class="headerlink" title="磁盘检验"></a>磁盘检验</h3><p>fsck（file system check）用来检查和维护不一致的文件系统。</p><p>若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查。</p><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsck [-t 文件系统] [-ACay] 装置名称</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-t : 给定档案系统的型式，若在 /etc/fstab 中已有定义或 kernel 本身已支援的则不需加上此参数</li><li>-s : 依序一个一个地执行 fsck 的指令来检查</li><li>-A : 对/etc/fstab 中所有列出来的 分区（partition）做检查</li><li>-C : 显示完整的检查进度</li><li>-d : 打印出 e2fsck 的 debug 结果</li><li>-p : 同时有 -A 条件时，同时有多个 fsck 的检查一起执行</li><li>-R : 同时有 -A 条件时，省略 / 不检查</li><li>-V : 详细显示模式</li><li>-a : 如果检查有错则自动修复</li><li>-r : 如果检查有错则由使用者回答是否修复</li><li>-y : 选项指定检测每个文件是自动输入yes，在不确定那些是不正常的时候，可以执行 # fsck -y 全部检查修复。</li></ul><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>强制检测 /dev/hdc6 分区:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># fsck -C -f -t ext3 /dev/hdc6 </span></span><br><span class="line">fsck 1.39 (29-May-2006)</span><br><span class="line">e2fsck 1.39 (29-May-2006)</span><br><span class="line">Pass 1: Checking inodes, blocks, and sizes</span><br><span class="line">Pass 2: Checking directory structure</span><br><span class="line">Pass 3: Checking directory connectivity</span><br><span class="line">Pass 4: Checking reference counts</span><br><span class="line">Pass 5: Checking group summary information</span><br><span class="line">vbird_logical: 11/251968 files (9.1% non-contiguous), 36926/1004046 blocks</span><br></pre></td></tr></table></figure><p>如果没有加上 -f 的选项，则由于这个文件系统不曾出现问题，检查的经过非常快速！若加上 -f 强制检查，才会一项一项的显示过程。</p><h3 id="磁盘挂载与卸除"><a href="#磁盘挂载与卸除" class="headerlink" title="磁盘挂载与卸除"></a>磁盘挂载与卸除</h3><p>Linux 的磁盘挂载使用 <code>mount</code> 命令，卸载使用 <code>umount</code> 命令。</p><p>磁盘挂载语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n]  装置文件名  挂载点</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># mkdir /mnt/hdc6</span></span><br><span class="line">[root@www ~]<span class="comment"># mount /dev/hdc6 /mnt/hdc6</span></span><br><span class="line">[root@www ~]<span class="comment"># df</span></span><br><span class="line">Filesystem           1K-blocks      Used Available Use% Mounted on</span><br><span class="line">.....中间省略.....</span><br><span class="line">/dev/hdc6              1976312     42072   1833836   3% /mnt/hdc6</span><br></pre></td></tr></table></figure><p>磁盘卸载命令 <code>umount</code> 语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount [-fn] 装置文件名或挂载点</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；</li><li>-n ：不升级 /etc/mtab 情况下卸除。</li></ul><p>卸载/dev/hdc6</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># umount /dev/hdc6     </span></span><br></pre></td></tr></table></figure><p>Linux 系统中“一切皆文件”，所有文件都放置在以根目录为树根的树形目录结构中。在 Linux 看来，任何硬件设备也都是文件，它们各有自己的一套文件系统（文件目录结构）。</p><p>因此产生的问题是，当在 Linux 系统中使用这些硬件设备时，只有将Linux本身的文件目录与硬件设备的文件目录合二为一，硬件设备才能为我们所用。合二为一的过程称为“挂载”。</p><p>如果不挂载，通过Linux系统中的图形界面系统可以查看找到硬件设备，但命令行方式无法找到。</p><p>挂载，指的就是将设备文件中的顶级目录连接到 Linux 根目录下的某一目录（最好是空目录），访问此目录就等同于访问设备文件。</p><p>纠正一个误区，并不是根目录下任何一个目录都可以作为挂载点，由于挂载操作会使得原有目录中文件被隐藏，因此根目录以及系统原有目录都不要作为挂载点，会造成系统异常甚至崩溃，挂载点最好是新建的空目录。</p><p>举个例子，我们想通过命令行访问某个 U 盘中的数据，图 1 所示为 U 盘文件目录结构和 Linux 系统中的文件目录结构。</p><p><img src="http://c.biancheng.net/uploads/allimg/190321/2-1Z321130921V9.gif"></p><p>图 1 中可以看到，目前 U 盘和 Linux 系统文件分属两个文件系统，还无法使用命令行找到 U 盘文件，需要将两个文件系统进行挂载。</p><p>接下来，我们在根目录下新建一个目录 /sdb-u，通过挂载命令将 U 盘文件系统挂载到此目录，挂载效果如图 2 所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/190321/2-1Z321130I44B.gif"></p><p>可以看到，U 盘文件系统已经成为 Linux 文件系统目录的一部分，此时访问 /sdb-u/ 就等同于访问 U 盘。</p><p>前面讲过，根目录下的 /dev/ 目录文件负责所有的硬件设备文件，事实上，当 U 盘插入 Linux 后，系统也确实会给 U 盘分配一个目录文件（比如 sdb1），就位于 /dev/ 目录下（/dev/sdb1），但无法通过 /dev/sdb1/ 直接访问 U 盘数据，访问此目录只会提供给你此设备的一些基本信息（比如容量）。</p><h3 id="LVM"><a href="#LVM" class="headerlink" title="LVM"></a>LVM</h3><p>  LVM是 Logical Volume Manager（逻辑<a href="http://baike.baidu.com/view/3796024.htm">卷管理</a>）的简写，它是Linux环境下对<a href="http://baike.baidu.com/view/1514781.htm">磁盘分区</a>进行管理的一种机制。</p><h4 id="为什么使用LVM"><a href="#为什么使用LVM" class="headerlink" title="为什么使用LVM"></a>为什么使用LVM</h4><p>   直接使用fdisk分区挂载的话，随着时间的推移，数据量越来越大，硬盘空间越来越小，要想扩充容量的话，就必须挂载新硬盘然后做数据迁移，这就必然导致前台业务的停止，不符合企业需求，因此完美的解决方法应该是在零停机前提下可以自如对文件系统的大小进行调整，可以方便实现文件系统跨越不同磁盘和分区。Linux提供的逻辑盘卷管理（LVM，Logical Volume Manager）机制就是一个完美的解决方案。</p><p>​     LVM逻辑卷管理通过将底层物理硬盘抽象封装起来，以逻辑卷的形式表现给上层系统，逻辑卷的大小可以动态调整，而且不会丢失现有数据。新加入的硬盘也不会改变现有上层的逻辑卷，大大提高了磁盘管理的灵活性。</p><h4 id="LVM原理"><a href="#LVM原理" class="headerlink" title="LVM原理"></a>LVM原理</h4><p>先我们讨论以下几个LVM术语：</p><p>​     <strong>物理存储介质（The physical media****）</strong>：这里指系统的存储设备：硬盘，如：/dev/hda、/dev/sda等等，是存储系统最低层的存储单元。</p><p>​     <strong>物理卷（physical volume****）</strong>：物理卷就是指硬盘分区或从逻辑上与磁盘分区具有同样功能的设备(如RAID)，是LVM的基本存储逻辑块，但和基本的物理存储介质（如分区、磁盘等）比较，却包含有与LVM相关的管理参数。</p><p>​     <strong>卷组（Volume Group****）</strong>：LVM卷组类似于非LVM系统中的物理硬盘，其由物理卷组成。可以在卷组上创建一个或多个“LVM分区”（逻辑卷），LVM卷组由一个或多个物理卷组成。</p><p>​     <strong>逻辑卷（logical volume****）</strong>：LVM的逻辑卷类似于非LVM系统中的硬盘分区，在逻辑卷之上可以建立文件系统(比如/home或者/usr等)。</p><p>​     <strong>PE<strong><strong>（physical extent</strong></strong>）</strong>：每一个物理卷被划分为称为PE(Physical Extents)的基本单元，具有唯一编号的PE是可以被LVM寻址的最小单元。PE的大小是可配置的，默认为4MB。</p><p>​     <strong>LE<strong><strong>（logical extent</strong></strong>）</strong>：逻辑卷也被划分为被称为LE(Logical Extents) 的可被寻址的基本单位。在同一个卷组中，LE的大小和PE是相同的，并且一一对应。</p><p>​     一块硬盘（物理存储介质）被格式化为物理卷（<strong>physical volume</strong>）,其内部被分成若干个默认大小为4M的PE（physical extent），然后在PV的基础上创建卷组（<strong>Volume Group</strong>），可以把一个或者多个PV加到VG中，VG就好像一个空间池，假如多少个PV，VG就有多大的容量，最后基于VG创建逻辑卷（<strong>logical volume</strong>）  ，一个逻辑卷就是若干个PE，然后将LV格式化再挂载（将LV当成是分区）</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fs3.51cto.com%2Fwyfs02%2FM02%2F73%2FE7%2FwKiom1YJW-zwfDURAAFVqFhodiw260.jpg&refer=http%3A%2F%2Fs3.51cto.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1614688218&t=30f4337674f77310e0cea309c0e12e5a"></p><p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3301810329,2804647527&fm=26&gp=0.jpg"></p><p>​     1、物理磁盘被格式化为PV，空间被分为一个个PE</p><p>​     2、不同的PV加入同一个VG，不同PV的PE全部进入VG的PE池内</p><p>​     3、LV基于PE创建，大小为PE的整数倍，组成LV的PE可能自来不同的物理磁盘</p><p>​     4、LV现在就直接可以格式化后挂载使用了</p><p>​     5、LV的扩充缩减实际上就是增加或减少组成该LV的PE的数量，其过程不会丢失数据</p><h4 id="LVM常用命令"><a href="#LVM常用命令" class="headerlink" title="LVM常用命令"></a>LVM常用命令</h4><p><code>lvdisplay</code>（显示当前的 logical volume）</p><p><code>vgdisplay</code>（显示当前的 volume group）</p><p><strong>备注：</strong> 注意 <code>VG SIZE</code>，这里应该是你当前的可用空间大小，待扩容完毕，这里显示的应该是最终的大小</p><p><code>pvdisplay</code>（显示当前的 physical volume）</p><h4 id="LVM扩容"><a href="#LVM扩容" class="headerlink" title="LVM扩容"></a>LVM扩容</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux&quot;&gt;&lt;a href=&quot;#Linux&quot; class=&quot;headerlink&quot; title=&quot;Linux&quot;&gt;&lt;/a&gt;Linux&lt;/h1&gt;&lt;h2 id=&quot;Linux-简介&quot;&gt;&lt;a href=&quot;#Linux-简介&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="系统管理" scheme="http://example.com/categories/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    
    <category term="运维" scheme="http://example.com/categories/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>ssm</title>
    <link href="http://example.com/spring/ssm/"/>
    <id>http://example.com/spring/ssm/</id>
    <published>2020-01-24T04:43:39.000Z</published>
    <updated>2021-11-06T03:43:27.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSM框架搭建项目"><a href="#SSM框架搭建项目" class="headerlink" title="SSM框架搭建项目"></a>SSM框架搭建项目</h1><h4 id="Spring-SpringMVC-Mybatis"><a href="#Spring-SpringMVC-Mybatis" class="headerlink" title="Spring+SpringMVC+Mybatis"></a><code>Spring+SpringMVC+Mybatis</code></h4><h2 id="1、web工程入口"><a href="#1、web工程入口" class="headerlink" title="1、web工程入口"></a>1、web工程入口</h2><p><code>web工程</code>入口好比<code>javaSE</code>工程的<code>main函数</code>，对于web工程而言，其入口便是<code>web.xml</code>。</p><h4 id="web-xml分解"><a href="#web-xml分解" class="headerlink" title="web.xml分解"></a>web.xml分解</h4><h5 id="1-1加载spring配置文件"><a href="#1-1加载spring配置文件" class="headerlink" title="1.1加载spring配置文件"></a>1.1加载spring配置文件</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:spring-context*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="1-1-1-Spring如何使用多个xml配置文件"><a href="#1-1-1-Spring如何使用多个xml配置文件" class="headerlink" title="1.1.1 Spring如何使用多个xml配置文件"></a>1.1.1 Spring如何使用多个xml配置文件</h5><p>1、在web.xml中定义contextConfigLocation参数，Spring会使用这个参数去加载所有逗号分隔的xml文件，如果没有这个参数，Spring默认加载web-inf/applicationContext.xml文件。 例如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">　<span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">        classpath*:conf/spring/applicationContext_core*.xml,</span><br><span class="line">        classpath*:conf/spring/applicationContext_dict*.xml,</span><br><span class="line">        classpath*:conf/spring/applicationContext_hibernate.xml,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span> </span><br></pre></td></tr></table></figure><p><code>ontextConfigLocation</code> 参数的<code>&lt;param-value&gt;</code>定义了要装入的 <code>Spring</code> 配置文件。</p><h6 id="原理：利用ServletContextListener-实现"><a href="#原理：利用ServletContextListener-实现" class="headerlink" title="原理：利用ServletContextListener 实现"></a>原理：利用ServletContextListener 实现</h6><p><code>Spring</code>提供<code>ServletContextListener</code> 的一个实现类<code>ContextLoaderListener</code> ，该类可以作为listener 使用，它会在创建时自动查找WEB-INF/ 下的applicationContext.xml 文件。因此，如果只有一个配置文件，并且文件名为applicationContext.xml ，则只需在web.xml文件中增加如下代码即可:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果没有contextConfigLocation 指定配置文件，则Spring 自动查找applicationContext.xml 配置文件。如果有contextConfigLocation，则利用该参数确定的配置文件。该参数指定的一个字符串，Spring 的ContextLoaderListener 负责将该字符串分解成多个配置文件，逗号”，”、空格” “及分号”;”都可作为字符串的分割符。如果既没有applicationContext.xml 文件，也没有使用contextConfigLocation参数确定配置文件，或者contextConfigLocation确定的配置文件不存在。都将导致Spring 无法加载配置文件或无法正常创建ApplicationContext 实例</p><h5 id="1-2-字符过滤器"><a href="#1-2-字符过滤器" class="headerlink" title="1.2 字符过滤器"></a>1.2 字符过滤器</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="1-3-控制器（DisPatcher）"><a href="#1-3-控制器（DisPatcher）" class="headerlink" title="1.3 控制器（DisPatcher）"></a>1.3 控制器（DisPatcher）</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:/spring-mvc*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="01-spring依赖关系"><a href="#01-spring依赖关系" class="headerlink" title="01.spring依赖关系"></a>01.spring依赖关系</h2><p><img src="https://i.loli.net/2021/11/06/GXalp7bLA591Q4R.png" alt="image-20211106111631467"></p><p><strong>一、非web工程的spring使用</strong></p><p>1、使用maven引入jar包：spring-context包</p><p>maven会自动引入spring-context依赖的包 ！！！</p><p><strong>补充：spring各个jar包之间的依赖关系</strong></p><p><a href="https://blog.csdn.net/a909301740/article/details/78332991">https://blog.csdn.net/a909301740/article/details/78332991</a></p><p><strong>spring的主要模块:</strong></p><p>IOC </p><ul><li>core：资源访问，类型转换</li><li>beans：bean工厂</li><li>expression：${}获取属性</li><li>context：核心接口ApplicationContext</li></ul><p>AOP </p><ul><li>aop：面向切面编程的实现</li><li>aspects：对AspectJ的整合</li></ul><p>DAO </p><ul><li>jdbc：通过jdbc模板类访问数据库</li><li>tx：事务的实现</li><li>orm：与hibernate，mybatis的集成</li><li>oxm：对象与xml数据之间的相互转换</li><li>jms：系统之间发送消息，异步通信</li></ul><p>Web </p><ul><li>web：与web项目的整合</li><li>webmvc：子模块springMVC</li></ul><p>Test </p><ul><li>test：测试</li></ul><ol><li>spring-core的依赖关系：core只依赖commons-logging</li></ol><p><img src="https://i.loli.net/2021/11/06/PD3hNc29BJHti5L.png" alt="image-20211106111656342"></p><ul><li>2、spring-beans：beans依赖于core</li></ul><p><img src="https://i.loli.net/2021/11/06/2OkuYVRXE7biDjg.png" alt="img"></p><ul><li>spring-expression：expression和beans一样依赖于core</li></ul><p><img src="https://i.loli.net/2021/11/06/2OkuYVRXE7biDjg.png" alt="img"></p><ul><li>spring-tx：依赖于beans</li></ul><p><img src="https://i.loli.net/2021/11/06/2OkuYVRXE7biDjg.png" alt="img"></p><h2 id="02-Spring-Web"><a href="#02-Spring-Web" class="headerlink" title="02.Spring Web"></a>02.Spring Web</h2><h3 id="Spring-整合-Web"><a href="#Spring-整合-Web" class="headerlink" title="Spring 整合 Web"></a>Spring 整合 Web</h3><h4 id="容器初始化"><a href="#容器初始化" class="headerlink" title="容器初始化"></a>容器初始化</h4><p>启动容器时需要自动装载 <code>ApplicationContext</code>，Spring 提供的 <code>ContextLoaderListener</code> 就是为了自动装配 <code>ApplicationContext</code> 的配置信息</p><h4 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h4><p>需要在 pom.xml 增加 org.springframework:spring-web 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.17.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置web-xml"><a href="#配置web-xml" class="headerlink" title="配置web.xml"></a>配置web.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;3.1&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-context*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="ApplicationContextAware"><a href="#ApplicationContextAware" class="headerlink" title="ApplicationContextAware"></a><code>ApplicationContextAware</code></h3><p>当一个类实现了这个接口（<code>ApplicationContextAware</code>）之后，这个类就可以方便获得 <code>ApplicationContext</code> 中的所有 bean。换句话说，就是这个类可以直接获取 Spring 配置文件中，所有有引用到的 Bean 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.funtl.my.shop.commons.context;<span class="keyword">import</span> org.apache.commons.lang3.Validate;<span class="keyword">import</span> org.slf4j.Logger;<span class="keyword">import</span> org.slf4j.LoggerFactory;<span class="keyword">import</span> org.springframework.beans.BeansException;<span class="keyword">import</span> org.springframework.beans.factory.DisposableBean;<span class="keyword">import</span> org.springframework.context.ApplicationContext;<span class="keyword">import</span> org.springframework.context.ApplicationContextAware;<span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">SpringContext</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>, <span class="title">DisposableBean</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(SpringContext.class);    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext ;    <span class="comment">/**     * 实现 DisposableBean 接口，在 Context 关闭时清理静态变量     * <span class="doctag">@throws</span> Exception     */</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;        logger.debug(<span class="string">&quot;清除 SpringContext 中的 ApplicationContext: &#123;&#125;&quot;</span>, applicationContext);        applicationContext = <span class="keyword">null</span>;    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;        SpringContext.applicationContext = applicationContext;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title">getApplicationContext</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span>  applicationContext;    &#125;    <span class="comment">/**     * 从静态变量 applicationContext 中获取 Bean，自动转型成所赋值对象的类型     * <span class="doctag">@param</span> beanId     * <span class="doctag">@param</span> &lt;T&gt;     * <span class="doctag">@return</span>     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T  <span class="title">getBean</span><span class="params">(String beanId)</span> </span>&#123;        <span class="keyword">return</span>  (T) applicationContext.getBean(beanId);    &#125;    <span class="comment">/**     * 从静态变量 applicationContext 中获取 Bean，自动转型成所赋值对象的类型     * <span class="doctag">@param</span> clazz     * <span class="doctag">@param</span> &lt;T&gt;     * <span class="doctag">@return</span>     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;        assertContextInjected();        <span class="keyword">return</span> applicationContext.getBean(clazz);    &#125;    <span class="comment">/**    **     * <span class="doctag">@Description</span>:    * <span class="doctag">@Param</span>: []     * <span class="doctag">@return</span>: void     * <span class="doctag">@Author</span>: kesen    * <span class="doctag">@Date</span>: 2019/6/12 8:32     */</span>     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assertContextInjected</span><span class="params">()</span> </span>&#123;        Validate.validState(applicationContext != <span class="keyword">null</span>, <span class="string">&quot;applicationContext 属性未注入，请在 spring-context.xml 配置中定义 SpringContext&quot;</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure><p>补充：需要在spring-context中装配SpringContext对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;springContext&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.funtl.my.shop.commons.context.SpringContext&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="附录：完整的POM-xml"><a href="#附录：完整的POM-xml" class="headerlink" title="附录：完整的POM.xml"></a>附录：完整的POM.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span>         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.funtl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-shop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>4.3.17.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span>        <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span>        <span class="tag">&lt;<span class="name">servlet.version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">servlet.version</span>&gt;</span>        <span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">slf4j.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;servlet.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span>                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span>                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="完整的web-xml"><a href="#完整的web-xml" class="headerlink" title="完整的web.xml"></a>完整的web.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span>         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span>         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span>        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:spring-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span>    <span class="tag">&lt;<span class="name">listener</span>&gt;</span>        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span>    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span>    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span>        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LoginController<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.funtl.my.shop.web.controller.LoginController<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span>    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span>    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LoginController<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/login<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="完整的spring-context-xml"><a href="#完整的spring-context-xml" class="headerlink" title="完整的spring-context.xml"></a>完整的spring-context.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd&quot;</span>&gt;</span>    <span class="comment">&lt;!--Dao--&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.funtl.my.shop.dao.impl.UserDaoImpl&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;springContext&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.funtl.my.shop.commons.context.SpringContext&quot;</span> /&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.funtl.my.shop.service.impl.UserServiceImpl&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Bean-的装配方式"><a href="#Bean-的装配方式" class="headerlink" title="Bean 的装配方式"></a>Bean 的装配方式</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>截止目前为止，咱们 Bean 的装配方式是通过代码 <code>getBean()</code> 的方式从容器获取指定的 Bean 实例，容器首先会调用 Bean 类的无参构造器，创建空值的实例对象。除了使用 <code>getBean()</code> 的装配方式外，还可以使用注解的装配方式</p><h4 id="容器中-Bean-的作用域"><a href="#容器中-Bean-的作用域" class="headerlink" title="容器中 Bean 的作用域"></a>容器中 Bean 的作用域</h4><p>在学习 Bean 的装配方式之前，我们先了解一下 Bean 的作用域。当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。Spring 支持 5 种作用域。</p><ul><li>singleton：单态模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。默认为单态的。</li><li>prototype：原型模式。即每次使用 getBean 方法获取的同一个 <code>&lt;bean /&gt;</code> 的实例都是一个新的实例。</li><li>request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。</li><li>session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。</li><li>global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中，global-session 与 session 是等同的。</li></ul><p>注意事项：</p><ul><li>对于 scope 的值 request、session 与 global session，只有在 Web 应用中使用 Spring 时，该作用域才有效。</li><li>对于 scope 为 singleton 的单例模式，该 Bean 是在容器被创建时即被装配好了。</li><li>对于 scope 为 prototype 的原型模式，Bean 实例是在代码中使用该 Bean 实例时才进行装配的</li></ul><p>基于注解的装配方式</p><p>对于 DI 使用注解，将不再需要在 Spring 配置文件中声明 Bean 实例。Spring 中使用注解， 需要在原有 Spring 运行环境基础上再做一些改变</p><p>需要在 Spring 配置文件中配置组件扫描器，用于在指定的基本包中扫描注解</p><h5 id="spring-context-xml"><a href="#spring-context-xml" class="headerlink" title="spring-context.xml"></a>spring-context.xml</h5><p>配置组件扫描器，用于在指定的基本包中扫描注解</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span>       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">context:annotation-config</span> /&gt;</span>    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.funtl.leeshop&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="常用的注解"><a href="#常用的注解" class="headerlink" title="常用的注解"></a>常用的注解</h5><ul><li><code>@Repository</code>：用于对 DAO 实现类进行注解</li><li><code>@Service</code>：用于对 Service 实现类进行注解</li><li><code>@Controller</code>：用于对 Controller 实现类进行注解</li><li><code>@Component</code>:当该类不是MVC层次的类时，考虑用该注解</li></ul><h6 id="Component"><a href="#Component" class="headerlink" title="@Component"></a><code>@Component</code></h6><p>需要在类上使用注解 <code>@Component</code>，该注解的 <code>value</code>属性用于指定该 bean 的 id 值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(value = &quot;student&quot;)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;    <span class="keyword">private</span> Long id;    <span class="keyword">private</span> String name;    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> id;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;        <span class="keyword">this</span>.id = id;    &#125;    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> name;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;        <span class="keyword">this</span>.name = name;    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +                <span class="string">&quot;id=&quot;</span> + id +                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +                <span class="string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</span><br></pre></td></tr></table></figure><h6 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a><code>@Scope</code></h6><p>需要在类上使用注解 @Scope，其 value 属性用于指定作用域。默认为 singleton。 <img src="https://i.loli.net/2021/11/06/qS4N9pDQJEfVuX8.png" alt="image-20211106112611541"></p><h6 id="Value"><a href="#Value" class="headerlink" title="@Value"></a><code>@Value</code></h6><p>需要在属性上使用注解 @Value，该注解的 value 属性用于指定要注入的值。</p><p><img src="https://i.loli.net/2021/11/06/chIz5lsK32tAdaw.png" alt="image-20211106112650140"></p><p>使用该注解完成属性注入时，类中无需 setter。当然，若属性有 setter，则也可将其加到 setter 上。</p><h6 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a><code>@Autowired</code></h6><p>需要在域属性上使用注解 @Autowired，该注解默认使用 <strong>按类型自动装配 Bean 的方式。</strong></p><p>使用该注解完成属性注入时，类中无需 setter。当然，若属性有 setter，则也可将其加到 setter 上。</p><p><img src="https://i.loli.net/2021/11/06/Cef3syQujUL4vz6.png" alt="image-20211106112715100"></p><p>注明：Student类自动注入school实例，相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Schoool school = <span class="keyword">new</span> School();</span><br></pre></td></tr></table></figure><h6 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a><code>@Resource</code></h6><p>需要在域属性上使用注解 <code>@Resource</code>，该注解有一个 name 属性，可以创建指定的 bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource(name = &quot;userService&quot;)</span><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure><h6 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a><code>@PostConstruct</code></h6><p>在方法上使用 <code>@PostConstruct</code>相当于初始化 </p><p><img src="https://i.loli.net/2021/11/06/U4AbDO8jIaEC9JS.png" alt="image-20211106113053850"></p><h4 id="注解与-XML-配置的区别"><a href="#注解与-XML-配置的区别" class="headerlink" title="注解与 XML 配置的区别"></a>注解与 XML 配置的区别</h4><p>注解的好处是，配置方便，直观。但其弊端也显而易见：以硬编码的方式写入到了 Java 代码中，其修改是需要重新编译代码的。</p><p>XML 配置方式的最大好处是，对其所做修改，无需编译代码，只需重启服务器即可将新的配置加载。</p><p>若注解与 XML 同用，XML 的优先级要高于注解。这样做的好处是，需要对某个 Bean 做修改，只需修改配置文件即可。</p><h3 id="浏览器端存储技术简介"><a href="#浏览器端存储技术简介" class="headerlink" title="浏览器端存储技术简介"></a>浏览器端存储技术简介</h3><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p><code>Cookie</code> 是指存储在用户本地终端上的数据，同时它是与具体的 Web 页面或者站点相关的。Cookie 数据会自动在 Web 浏览器和 Web 服务器之间传输，也就是说 HTTP 请求发送时，会把保存在该请求域名下的所有 Cookie 值发送给 Web 服务器，因此服务器端脚本是可以读、写存储在客户端的 Cookie 的操作。</p><h4 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h4><p>在 HTML5 中，新加入了一个 localStorage 特性，这个特性主要是用来作为本地存储来使用的，解决了 Cookie 存储空间不足的问题(Cookie 中每条 Cookie 的存储空间为 4k)，localStorage 中一般浏览器支持的是 5M 大小，这个在不同的浏览器中 localStorage 会有所不同 !</p><h4 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h4><p>SessionStorage 与 LocalStorage 的唯一一点区别就是 LocalStorage 属于永久性存储，而 SessionStorage 属于当会话结束的时候，SessionStorage 中的键值对就会被清空。 </p><h4 id="UserData、GlobalStorage、Google-Gear"><a href="#UserData、GlobalStorage、Google-Gear" class="headerlink" title="UserData、GlobalStorage、Google Gear"></a>UserData、GlobalStorage、Google Gear</h4><p>这三种的使用都有一定的局限性，例如</p><ul><li>userData 是 IE 浏览器专属，它的容量可以达到 640K，这种方案可靠，不需要安装额外插件，只不过它仅在IE下有效</li><li>globalStorage 适用于 Firefox 2+ 的浏览器，类似于 IE 的 userData</li><li>google gear 是谷歌开发出的一种本地存储技术，需要安装 Gear 组件</li><li></li></ul><h4 id="Flash-ShareObject（Flash-Cookie）"><a href="#Flash-ShareObject（Flash-Cookie）" class="headerlink" title="Flash ShareObject（Flash Cookie）"></a>Flash ShareObject（Flash Cookie）</h4><p>这种方式能能解决上面提到的 Cookie 存储的两个弊端，而且能够跨浏览器，应该说是目前最好的本地存储方案。不过，需要在页面中插入一个 Flash，当浏览器没有安装 Flash 控件时就不能用了。所幸的是，没有安装 Flash 的用户极少</p><h4 id="CookieUtils"><a href="#CookieUtils" class="headerlink" title="CookieUtils"></a>CookieUtils</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.funtl.leeshop.commons.utils;<span class="keyword">import</span> javax.servlet.http.Cookie;<span class="keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="keyword">import</span> javax.servlet.http.HttpServletResponse;<span class="keyword">import</span> java.io.UnsupportedEncodingException;<span class="keyword">import</span> java.net.URLDecoder;<span class="keyword">import</span> java.net.URLEncoder;<span class="comment">/** * Cookie 工具类 * &lt;p&gt;Title: CookieUtils&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * * <span class="doctag">@author</span> Lusifer * <span class="doctag">@version</span> 1.0.0 * <span class="doctag">@date</span> 2017/12/10 22:00 */</span><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieUtils</span> </span>&#123;    <span class="comment">/**     * 得到Cookie的值, 不编码     *     * <span class="doctag">@param</span> request     * <span class="doctag">@param</span> cookieName     * <span class="doctag">@return</span>     */</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCookieValue</span><span class="params">(HttpServletRequest request, String cookieName)</span> </span>&#123;        <span class="keyword">return</span> getCookieValue(request, cookieName, <span class="keyword">false</span>);    &#125;    <span class="comment">/**     * 得到Cookie的值,     *     * <span class="doctag">@param</span> request     * <span class="doctag">@param</span> cookieName     * <span class="doctag">@return</span>     */</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCookieValue</span><span class="params">(HttpServletRequest request, String cookieName, <span class="keyword">boolean</span> isDecoder)</span> </span>&#123;        Cookie[] cookieList = request.getCookies();        <span class="keyword">if</span> (cookieList == <span class="keyword">null</span> || cookieName == <span class="keyword">null</span>) &#123;            <span class="keyword">return</span> <span class="keyword">null</span>;        &#125;        String retValue = <span class="keyword">null</span>;        <span class="keyword">try</span> &#123;            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cookieList.length; i++) &#123;                <span class="keyword">if</span> (cookieList[i].getName().equals(cookieName)) &#123;                    <span class="keyword">if</span> (isDecoder) &#123;                        retValue = URLDecoder.decode(cookieList[i].getValue(), <span class="string">&quot;UTF-8&quot;</span>);                    &#125; <span class="keyword">else</span> &#123;                        retValue = cookieList[i].getValue();                    &#125;                    <span class="keyword">break</span>;                &#125;            &#125;        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> retValue;    &#125;    <span class="comment">/**     * 得到Cookie的值,     *     * <span class="doctag">@param</span> request     * <span class="doctag">@param</span> cookieName     * <span class="doctag">@return</span>     */</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCookieValue</span><span class="params">(HttpServletRequest request, String cookieName, String encodeString)</span> </span>&#123;        Cookie[] cookieList = request.getCookies();        <span class="keyword">if</span> (cookieList == <span class="keyword">null</span> || cookieName == <span class="keyword">null</span>) &#123;            <span class="keyword">return</span> <span class="keyword">null</span>;        &#125;        String retValue = <span class="keyword">null</span>;        <span class="keyword">try</span> &#123;            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cookieList.length; i++) &#123;                <span class="keyword">if</span> (cookieList[i].getName().equals(cookieName)) &#123;                    retValue = URLDecoder.decode(cookieList[i].getValue(), encodeString);                    <span class="keyword">break</span>;                &#125;            &#125;        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> retValue;    &#125;    <span class="comment">/**     * 设置Cookie的值 不设置生效时间默认浏览器关闭即失效,也不编码     */</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCookie</span><span class="params">(HttpServletRequest request, HttpServletResponse response, String cookieName,                                 String cookieValue)</span> </span>&#123;        setCookie(request, response, cookieName, cookieValue, -<span class="number">1</span>);    &#125;    <span class="comment">/**     * 设置Cookie的值 在指定时间内生效,但不编码     */</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCookie</span><span class="params">(HttpServletRequest request, HttpServletResponse response, String cookieName,                                 String cookieValue, <span class="keyword">int</span> cookieMaxage)</span> </span>&#123;        setCookie(request, response, cookieName, cookieValue, cookieMaxage, <span class="keyword">false</span>);    &#125;    <span class="comment">/**     * 设置Cookie的值 不设置生效时间,但编码     */</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCookie</span><span class="params">(HttpServletRequest request, HttpServletResponse response, String cookieName,                                 String cookieValue, <span class="keyword">boolean</span> isEncode)</span> </span>&#123;        setCookie(request, response, cookieName, cookieValue, -<span class="number">1</span>, isEncode);    &#125;    <span class="comment">/**     * 设置Cookie的值 在指定时间内生效, 编码参数     */</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCookie</span><span class="params">(HttpServletRequest request, HttpServletResponse response, String cookieName,                                 String cookieValue, <span class="keyword">int</span> cookieMaxage, <span class="keyword">boolean</span> isEncode)</span> </span>&#123;        doSetCookie(request, response, cookieName, cookieValue, cookieMaxage, isEncode);    &#125;    <span class="comment">/**     * 设置Cookie的值 在指定时间内生效, 编码参数(指定编码)     */</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCookie</span><span class="params">(HttpServletRequest request, HttpServletResponse response, String cookieName,                                 String cookieValue, <span class="keyword">int</span> cookieMaxage, String encodeString)</span> </span>&#123;        doSetCookie(request, response, cookieName, cookieValue, cookieMaxage, encodeString);    &#125;    <span class="comment">/**     * 删除Cookie带cookie域名     */</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteCookie</span><span class="params">(HttpServletRequest request, HttpServletResponse response,                                    String cookieName)</span> </span>&#123;        doSetCookie(request, response, cookieName, <span class="string">&quot;&quot;</span>, -<span class="number">1</span>, <span class="keyword">false</span>);    &#125;    <span class="comment">/**     * 设置Cookie的值，并使其在指定时间内生效     *     * <span class="doctag">@param</span> cookieMaxage cookie生效的最大秒数     */</span>    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSetCookie</span><span class="params">(HttpServletRequest request, HttpServletResponse response,                                          String cookieName, String cookieValue, <span class="keyword">int</span> cookieMaxage, <span class="keyword">boolean</span> isEncode)</span> </span>&#123;        <span class="keyword">try</span> &#123;            <span class="keyword">if</span> (cookieValue == <span class="keyword">null</span>) &#123;                cookieValue = <span class="string">&quot;&quot;</span>;            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isEncode) &#123;                cookieValue = URLEncoder.encode(cookieValue, <span class="string">&quot;utf-8&quot;</span>);            &#125;            Cookie cookie = <span class="keyword">new</span> Cookie(cookieName, cookieValue);            <span class="keyword">if</span> (cookieMaxage &gt; <span class="number">0</span>)                cookie.setMaxAge(cookieMaxage);            <span class="keyword">if</span> (<span class="keyword">null</span> != request) &#123;<span class="comment">// 设置域名的cookie                String domainName = getDomainName(request);//                System.out.println(domainName);                if (!&quot;localhost&quot;.equals(domainName)) &#123;                    cookie.setDomain(domainName);                &#125;            &#125;            cookie.setPath(&quot;/&quot;);            response.addCookie(cookie);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    /**     * 设置Cookie的值，并使其在指定时间内生效     *     * @param cookieMaxage cookie生效的最大秒数     */    private static final void doSetCookie(HttpServletRequest request, HttpServletResponse response,                                          String cookieName, String cookieValue, int cookieMaxage, String encodeString) &#123;        try &#123;            if (cookieValue == null) &#123;                cookieValue = &quot;&quot;;            &#125; else &#123;                cookieValue = URLEncoder.encode(cookieValue, encodeString);            &#125;            Cookie cookie = new Cookie(cookieName, cookieValue);            if (cookieMaxage &gt; 0)                cookie.setMaxAge(cookieMaxage);            if (null != request) &#123;// 设置域名的cookie                String domainName = getDomainName(request);//                System.out.println(domainName);                if (!&quot;localhost&quot;.equals(domainName)) &#123;                    cookie.setDomain(domainName);                &#125;            &#125;            cookie.setPath(&quot;/&quot;);            response.addCookie(cookie);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    /**     * 得到cookie的域名     */    private static final String getDomainName(HttpServletRequest request) &#123;        String domainName = null;        String serverName = request.getRequestURL().toString();        if (serverName == null || serverName.equals(&quot;&quot;)) &#123;            domainName = &quot;&quot;;        &#125; else &#123;            serverName = serverName.toLowerCase();            serverName = serverName.substring(7);            final int end = serverName.indexOf(&quot;/&quot;);            serverName = serverName.substring(0, end);            final String[] domains = serverName.split(&quot;\\.&quot;);            int len = domains.length;            if (len &gt; 3) &#123;                // www.xxx.com.cn                domainName = &quot;.&quot; + domains[len - 3] + &quot;.&quot; + domains[len - 2] + &quot;.&quot; + domains[len - 1];            &#125; else if (len &lt;= 3 &amp;&amp; len &gt; 1) &#123;                // xxx.com or xxx.cn                domainName = &quot;.&quot; + domains[len - 2] + &quot;.&quot; + domains[len - 1];            &#125; else &#123;                domainName = serverName;            &#125;        &#125;        if (domainName != null &amp;&amp; domainName.indexOf(&quot;:&quot;) &gt; 0) &#123;            String[] ary = domainName.split(&quot;\\:&quot;);            domainName = ary[0];        &#125;        return domainName;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="00-简介"><a href="#00-简介" class="headerlink" title="00.简介"></a>00.简介</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Spring MVC 也叫 Spring Web MVC ，属于展示层框架。SpringMVC 是 Spring 框架的一部分。</p><p>Spring Web MVC 框架提供了 MVC (模型 - 视图 - 控制器) 架构和用于开发灵活和松散耦合的 Web 应用程序的组件。 MVC 模式导致应用程序的不同方面(输入逻辑，业务逻辑和 UI 逻辑)分离，同时提供这些元素之间的松散耦合。</p><ul><li>模型 (Model)：封装了应用程序数据，通常它们将由 POJO 类组成。</li><li>视图 (View)：负责渲染模型数据，一般来说它生成客户端浏览器可以解释 HTML 输出。</li><li>控制器 (Controller)：负责处理用户请求并构建适当的模型，并将其传递给视图进行渲染</li></ul><p>【注】 Servlet 使用不灵活 每创建一个Servlet都需要到web.xml中配置一次 默认调用doGet或者doPost方法</p><h3 id="DispatcherServlet-组件类"><a href="#DispatcherServlet-组件类" class="headerlink" title="DispatcherServlet 组件类"></a>DispatcherServlet 组件类</h3><p>Spring Web MVC 框架是围绕 <code>DispatcherServlet</code> 设计的，它处理所有的 HTTP 请求和响应。 Spring Web MVC DispatcherServlet 的请求处理工作流如下图所示： <img src="https://i.loli.net/2021/11/06/NgPMBoq2drCVRc6.png" alt="image-20211106113352289"></p><p>以下是对应于到 DispatcherServlet 的传入 HTTP 请求的事件顺序：</p><ul><li>在接收到 HTTP 请求后，DispatcherServlet 会查询 HandlerMapping 以调用相应的 Controller。</li><li>Controller 接受请求并根据使用的 GET 或 POST 方法调用相应的服务方法。</li><li>服务方法将基于定义的业务逻辑设置模型数据，并将视图名称返回给 DispatcherServlet。</li><li>DispatcherServlet 将从 ViewResolver 获取请求的定义视图。</li><li>当视图完成，DispatcherServlet 将模型数据传递到最终的视图，并在浏览器上呈现。</li><li>所有上述组件，即: HandlerMapping，Controller 和 ViewResolver 是 WebApplicationContext 的一部分，它是普通 ApplicationContext 的扩展，带有 Web 应用程序所需的一些额外功能。</li></ul><h2 id="01-Spring-整合-Spring-MVC"><a href="#01-Spring-整合-Spring-MVC" class="headerlink" title="01.Spring 整合 Spring MVC"></a>01.Spring 整合 Spring MVC</h2><h3 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h3><p>在 <code>pom.xml</code> 配置文件中增加 <code>org.springframework:spring-webmvc</code> 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.17.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置-web-xml"><a href="#配置-web-xml" class="headerlink" title="配置 web.xml"></a>配置 <code>web.xml</code></h3><h4 id="CharacterEncodingFilter"><a href="#CharacterEncodingFilter" class="headerlink" title="CharacterEncodingFilter"></a>CharacterEncodingFilter</h4><p>配置字符集过滤器，用于解决中文编码问题</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span>    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span>    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span>        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span>    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span>        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span><span class="tag">&lt;/<span class="name">filter</span>&gt;</span><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span>    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h4><p>配置 Spring 的 Servlet 分发器处理所有 HTTP 的请求和响应</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span>    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span>    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span>        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:/spring-mvc*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span>    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置-Spring-MVC"><a href="#配置-Spring-MVC" class="headerlink" title="配置 Spring MVC"></a>配置 Spring MVC</h3><p>创建一个名为 <code>spring-mvc.xml</code> 文件来配置 MVC</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span>       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span>       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Spring MVC Configuration<span class="tag">&lt;/<span class="name">description</span>&gt;</span>    <span class="comment">&lt;!-- 加载配置属性文件 --&gt;</span>    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">ignore-unresolvable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">location</span>=<span class="string">&quot;classpath:myshop.properties&quot;</span>/&gt;</span>    <span class="comment">&lt;!-- 使用 Annotation 自动注册 Bean,只扫描 @Controller --&gt;</span>    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.lusifer.myshop&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span>    <span class="comment">&lt;!-- 默认的注解映射的支持 --&gt;</span>    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span>    <span class="comment">&lt;!-- 定义视图文件解析 --&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;web.view.prefix&#125;&quot;</span>/&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;web.view.suffix&#125;&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    <span class="comment">&lt;!-- 静态资源映射 --&gt;</span>    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/static/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/static/&quot;</span> <span class="attr">cache-period</span>=<span class="string">&quot;31536000&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>相关配置说明：</p><ul><li><code>context:property-placeholder</code>：动态加载属性配置文件以变量的方式引用需要的值</li><li><code>context:component-scan</code>：当前配置文件为 MVC 相关，故只需要扫描包含 <code>@Controller</code> 的注解即可，由于 <code>spring-context.xml</code> 配置文件中也配置了包扫描，所以还需要排除 <code>@Controller</code> 的注解扫描。</li><li><code>InternalResourceViewResolver</code>：视图文件解析器的一种，用于配置视图资源的路径和需要解释的视图资源文件类型，这里有两个需要配置的属性 <code>prefix</code>（前缀）以及 <code>suffix</code>（后缀）。<ul><li><code>prefix</code>：配置视图资源路径，如：<code>/WEB-INF/views/</code></li><li><code>suffix</code>：配置视图资源类型，如：<code>.jsp</code></li></ul></li><li><code>mvc:resources</code>：静态资源映射，主要用于配置静态资源文件存放路径，如：JS、CSS、Image 等</li></ul><h4 id="系统相关配置"><a href="#系统相关配置" class="headerlink" title="系统相关配置"></a>系统相关配置</h4><p>在 <code>spring-mvc.xnl</code> 中，我们配置了 <code>&lt;context:property-placeholder ignore-unresolvable=&quot;true&quot; location=&quot;classpath:myshop.properties&quot;/&gt;</code> 用于动态加载属性配置文件，实际开发中我们会将系统所需的一些配置信息封装到 <code>.properties</code> 配置文件中便于统一的管理。</p><p>创建一个名为 <code>myshop.properties</code> 的配置文件，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#============================##==== Framework settings ====##============================## \u89c6\u56fe\u6587\u4ef6\u5b58\u653e\u8def\u5f84web.view.prefix=/WEB-INF/views/web.view.suffix=.jsp</span><br></pre></td></tr></table></figure><h4 id="去掉-Spring-配置的重复扫描"><a href="#去掉-Spring-配置的重复扫描" class="headerlink" title="去掉 Spring 配置的重复扫描"></a>去掉 Spring 配置的重复扫描</h4><p>由于 <code>spring-mvc.xml</code> 中已经配置了 <code>@Controller</code> 注解的扫描而 <code>spring-context.xml</code> 中配置的是扫描全部注解，故在这里需要将 <code>@Controller</code> 注解的扫描配置排除。</p><p>修改 <code>spring-context.xml</code> 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用 Annotation 自动注册 Bean，在主容器中不扫描 @Controller 注解，在 SpringMVC 中只扫描 @Controller 注解。--&gt;</span><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.funtl.my.shop&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="第一个-Controller-控制器"><a href="#第一个-Controller-控制器" class="headerlink" title="第一个 Controller 控制器"></a>第一个 Controller 控制器</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.funtl.my.shop.web.controller;<span class="keyword">import</span> com.funtl.my.shop.service.UserService;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.stereotype.Controller;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<span class="meta">@Controllerpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> UserService userService;    <span class="meta">@RequestMapping(value = &#123;&quot;&quot;, &quot;login&quot;&#125;, method = RequestMethod.GET)</span>    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;    &#125;    <span class="meta">@RequestMapping(value = &quot;login&quot;, method = RequestMethod.POST)</span>    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(<span class="meta">@RequestParam(required = true)</span> String email, <span class="meta">@RequestParam(required = true)</span> String password)</span> </span>&#123;        <span class="keyword">return</span> <span class="string">&quot;redirect:/main&quot;</span>;    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="注解说明"><a href="#注解说明" class="headerlink" title="注解说明"></a>注解说明</h3><h4 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h4><p>在 Spring MVC 中，控制器 Controller 负责处理由 <code>DispatcherServlet</code> 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个 Model ，然后再把该 Model 返回给对应的 View 进行展示。在 Spring MVC 中提供了一个非常简便的定义 Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用 <code>@Controller</code> 标记一个类是 Controller ，然后使用 <code>@RequestMapping</code> 和 <code>@RequestParam</code> 等一些注解用以定义 URL 请求和 Controller 方法之间的映射，这样的 Controller 就能被外界访问到。此外 Controller 不会直接依赖于 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 等 <code>HttpServlet</code> 对象，它们可以通过 Controller 的方法参数灵活的获取到。</p><p><code>@Controller</code> 用于标记在一个类上，使用它标记的类就是一个 Spring MVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了 <code>@RequestMapping</code> 注解。<code>@Controller</code> 只是定义了一个控制器类，而使用 <code>@RequestMapping</code> 注解的方法才是真正处理请求的处理器。</p><h4 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h4><p>RequestMapping 是一个用来处理请求地址映射的注解，可用于类或方法上。<strong>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径</strong>。</p><p>RequestMapping 注解有六个属性：</p><ul><li>value， method<ul><li>value：指定请求的实际地址，指定的地址可以是 URI Template 模式</li><li>method：指定请求的method类型， GET、POST、PUT、DELETE 等</li></ul></li><li>consumes，produces<ul><li>consumes：指定处理请求的提交内容类型（Content-Type），例如 application/json, text/html</li><li>produces: 指定返回的内容类型，仅当 request 请求头中的(Accept)类型中包含该指定类型才返回</li></ul></li><li>params，headers<ul><li>params：指定 request 中必须包含某些参数值是，才让该方法处理</li><li>headers：指定 request 中必须包含某些指定的 header 值，才能让该方法处理请求</li></ul></li></ul><h2 id="Spring-MVC-拦截器的使用"><a href="#Spring-MVC-拦截器的使用" class="headerlink" title="Spring MVC 拦截器的使用"></a>Spring MVC 拦截器的使用</h2><h3 id="拦截器简介"><a href="#拦截器简介" class="headerlink" title="拦截器简介"></a>拦截器简介</h3><p>Spring Web MVC 的处理器拦截器，类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。</p><h3 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h3><p>日志记录：记录请求信息的日志，以便进行信息监控、信息统计、计算 PV（Page View）等</p><p>权限检查：如登录检测，进入处理器检测检测是否登录，如果没有直接返回到登录页面</p><p>性能监控：有时候系统在某段时间莫名其妙的慢，可以通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间</p><p>通用行为：读取 Cookie 得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取 Locale、Theme 信息等，只要是多个处理器都需要的即可使用拦截器实现</p><h3 id="第一个-Spring-MVC-拦截器"><a href="#第一个-Spring-MVC-拦截器" class="headerlink" title="第一个 Spring MVC 拦截器"></a>第一个 Spring MVC 拦截器</h3><p>Spring MVC 拦截器需要实现 <code>HandlerInterceptor</code> 接口，该接口定义了 3 个方法，分别为<code>preHandle()</code>、<code>postHandle()</code>和 <code>afterCompletion()</code>，咱们就是通过重写这 3 个方法来对用户的请求进行拦截处理.</p><ul><li><p><code>preHandle(HttpServletRequest request, HttpServletResponse response, Object handle)</code>：该方法在请求处理之前进行调用。Spring MVC 中的 <code>Interceptor</code> 是链式调用的，在一个应用中或者说是在一个请求中可以同时存在多个<code>Interceptor</code> 。每个 Interceptor 的调用会依据它的声明顺序依次执行，而且最先执行的都是 <code>Interceptor</code> 中的 <code>preHandle</code> 方法，所以可以在这个方法中进行一些前置初始化操作或者是对当前请求做一个预处理，也可以在这个方法中进行一些判断来决定请求是否要继续进行下去。该方法的返回值是布尔值 <code>Boolean</code> 类型的，当它返回为<code>false</code> 时，表示请求结束，后续的<code>Interceptor</code> 和 <code>Controller</code> 都不会再执行；当返回值为 <code>true</code> 时，就会继续调用下一个 <code>Intercepto</code>r 的 <code>preHandle</code> 方法，如果已经是最后一个<code>Interceptor</code> 的时候，就会是调用当前请求的<code>Controller</code> 中的方法</p></li><li><p><code>postHandle(HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView)</code>：通过 preHandle 方法的解释咱们知道这个方法包括后面要说到的 afterCompletion 方法都只能在当前所属的 Interceptor 的 preHandle 方法的返回值为 true 的时候，才能被调用。postHandle 方法在当前请求进行处理之后，也就是在 Controller 中的方法调用之后执行，但是它会在 DispatcherServlet 进行视图返回渲染之前被调用，所以咱们可以在这个方法中对 Controller 处理之后的 ModelAndView 对象进行操作。postHandle 方法被调用的方向跟 preHandle 是相反的，也就是说，先声明的 Interceptor 的 postHandle 方法反而会后执行。</p></li><li><p>afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex)：也是需要当前对应的 Interceptor 的 preHandle 方法的返回值为 true 时才会执行。因此，该方法将在整个请求结束之后，也就是在 DispatcherServlet 渲染了对应的视图之后执行，这个方法的主要作用是用于进行资源清理的工作。</p></li></ul><h4 id="创建登录拦截器"><a href="#创建登录拦截器" class="headerlink" title="创建登录拦截器"></a>创建登录拦截器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**** * <span class="doctag">@Description</span>: 登录拦截器，判断是否登录，如果未登录重定向到登录页面 ，否则放行* <span class="doctag">@Param</span>:  * <span class="doctag">@return</span>:  * <span class="doctag">@Author</span>: kesen* <span class="doctag">@Date</span>: 2019/6/15 19:46 */</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;        User user = (User)httpServletRequest.getSession().getAttribute(ConstantUtils.SESSION_USER);        <span class="comment">//判断是否登录        if (null == user) &#123;            httpServletResponse.sendRedirect(&quot;/login&quot;);            return false;        &#125;        //放行        return true;    &#125;    @Override    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123;       /* *//*postHandle在放行后执行*//*        // 如果请求来自登录页        if (modelAndView.getViewName().endsWith(&quot;login&quot;)) &#123;            // 则直接重定向到首页不再显示登录页            httpServletResponse.sendRedirect(&quot;/main&quot;);        &#125;*/    &#125;    @Override    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123;    &#125;</span></span><br></pre></td></tr></table></figure><p>登录拦截器，判断是否登录，如果未登录重定向到登录页面 ，否则放行</p><h4 id="在-spring-mvc-xml-中配置拦截器"><a href="#在-spring-mvc-xml-中配置拦截器" class="headerlink" title="在 spring-mvc.xml 中配置拦截器"></a>在 spring-mvc.xml 中配置拦截器</h4><p>拦截器定义后还需要在 spring-mvc.xml 中配置拦截器，代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 拦截器配置，拦截顺序：先执行后定义的，排在第一位的最后执行。--&gt;</span>    <span class="comment">&lt;!--拦截所有请求--&gt;</span>    <span class="comment">&lt;!--登录不能拦截，否则是死循环--&gt;</span>    <span class="comment">&lt;!--静态资源不能拦截--&gt;</span>    <span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span>        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span>            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span>            <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/static/**&quot;</span>/&gt;</span>            <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/login&quot;</span>/&gt;</span>            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.funtl.my.shop.web.interceptor.LoginInterceptor&quot;</span>/&gt;</span>        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span>        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span>            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span>            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.funtl.my.shop.web.interceptor.PermissInterceptor&quot;</span>/&gt;</span>        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span>    <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明：先执行权限检查拦截器，权限检查拦截所有请求，但是都放行，放行后执行<code>postHandle</code>,判断用户是否登录，如果登录，则<code>/login</code>请求重定向到首页</p><h4 id="权限检查拦截器"><a href="#权限检查拦截器" class="headerlink" title="权限检查拦截器"></a>权限检查拦截器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermissInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="keyword">return</span> <span class="keyword">true</span>;    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="comment">//以login结尾的请求        if (modelAndView.getViewName().endsWith(&quot;login&quot;)) &#123;            User user = (User) httpServletRequest.getSession().getAttribute(ConstantUtils.SESSION_USER);            if (null != user) &#123;                // 则直接重定向到首页不再显示登录页                httpServletResponse.sendRedirect(&quot;/main&quot;);            &#125;        &#125;    &#125;    @Override    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h1 id="Maven模块化开发"><a href="#Maven模块化开发" class="headerlink" title="Maven模块化开发"></a>Maven模块化开发</h1><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>创建一个名为 <code>my-shop</code> 的工程，<code>pom.xml</code> 文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span>         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.funtl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-shop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>        <span class="tag">&lt;<span class="name">modules</span>&gt;</span>        <span class="tag">&lt;/<span class="name">modules</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该项目称之为 <code>Root</code> 项目，主要作用是管理整个工程的全部模块，当有新模块加入时需要在 <code>modules</code> 元素下配置对应的模块目录</p><p>注：打包方式为pom</p><h2 id="创建统一的依赖管理"><a href="#创建统一的依赖管理" class="headerlink" title="创建统一的依赖管理"></a>创建统一的依赖管理</h2><p>创建一个名为 <code>my-shop-dependencies</code> 的项目，<code>pom.xml</code> 文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.funtl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-shop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-shop-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>my-shop-dependencies<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="comment">&lt;!-- 环境配置 --&gt;</span>        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span>        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span>        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>        <span class="comment">&lt;!-- 统一的依赖管理 --&gt;</span>        <span class="tag">&lt;<span class="name">commons-lang3.version</span>&gt;</span>3.5<span class="tag">&lt;/<span class="name">commons-lang3.version</span>&gt;</span>        <span class="tag">&lt;<span class="name">jstl.version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">jstl.version</span>&gt;</span>        <span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span>        <span class="tag">&lt;<span class="name">servlet-api.version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">servlet-api.version</span>&gt;</span>        <span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">slf4j.version</span>&gt;</span>        <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>4.3.17.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>            <span class="comment">&lt;!-- Spring Begin --&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>            <span class="comment">&lt;!-- Spring End --&gt;</span>            <span class="comment">&lt;!-- Servlet Begin --&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;servlet-api.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jstl.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>            <span class="comment">&lt;!-- Servlet End --&gt;</span>            <span class="comment">&lt;!-- Log Begin --&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jul-to-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>            <span class="comment">&lt;!-- Log End --&gt;</span>            <span class="comment">&lt;!-- Commons Begin --&gt;</span>            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;commons-lang3.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>            <span class="comment">&lt;!-- Commons End --&gt;</span>        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span>    <span class="tag">&lt;<span class="name">build</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>            <span class="comment">&lt;!-- Compiler 插件, 设定 JDK 版本 --&gt;</span>            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">source</span>&gt;</span>                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">target</span>&gt;</span>                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>$&#123;project.build.sourceEncoding&#125;<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span>                    <span class="tag">&lt;<span class="name">showWarnings</span>&gt;</span>true<span class="tag">&lt;/<span class="name">showWarnings</span>&gt;</span>                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>        <span class="comment">&lt;!-- 资源文件配置 --&gt;</span>        <span class="tag">&lt;<span class="name">resources</span>&gt;</span>            <span class="tag">&lt;<span class="name">resource</span>&gt;</span>                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span>                <span class="tag">&lt;<span class="name">excludes</span>&gt;</span>                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/*.java<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span>                <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span>            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span>            <span class="tag">&lt;<span class="name">resource</span>&gt;</span>                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span>            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span>        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span>    <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>PS：别忘记在 <code>my-shop</code> 工程的<code>pom.xml</code> 中增加<code>&lt;module&gt;my-shop-dependencies&lt;/module&gt;</code> 配置</p><p>注：该项目只是为了管理依赖</p><h2 id="创建通用的工具类（将工具类单独作为一个项目）"><a href="#创建通用的工具类（将工具类单独作为一个项目）" class="headerlink" title="创建通用的工具类（将工具类单独作为一个项目）"></a>创建通用的工具类（将工具类单独作为一个项目）</h2><p>创建一个名为<code>my-shop-commons</code> 的项目，<code>pom.xml</code>文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.funtl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-shop-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../my-shop-dependencies/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-shop-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>my-shop-commons<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>PS：别忘记在<code>my-shop</code> 工程的<code>pom.xml</code> 中增加 <code>&lt;module&gt;my-shop-commons&lt;/module&gt;</code> 配置</p><p>注：父项目为依赖管理项目，目的就是为了统一管理依赖版本。</p><h2 id="创建领域模型"><a href="#创建领域模型" class="headerlink" title="创建领域模型"></a>创建领域模型</h2><p>创建一个名为 my-shop-domain 的项目，pom.xml 文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.funtl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-shop-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../my-shop-dependencies/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-shop-domain<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>my-shop-domain<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>PS：别忘记在 my-shop 工程的 pom.xml 中增加 <module>my-shop-domain</module> 配置</p><h2 id="创建管理后台"><a href="#创建管理后台" class="headerlink" title="创建管理后台"></a>创建管理后台</h2><p>创建一个名为 my-shop-web-admin 的项目，pom.xml 文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.funtl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-shop-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../my-shop-dependencies/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span>    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-shop-web-admin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>my-shop-web-admin<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.funtl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-shop-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.parent.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.funtl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-shop-domain<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.parent.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>PS：别忘记在 my-shop 工程的 pom.xml 中增加 <module>my-shop-web-admin</module> 配置</p><p>注：后台管理依赖领域模型和工具类项目</p><h2 id="创建商城前端"><a href="#创建商城前端" class="headerlink" title="创建商城前端"></a>创建商城前端</h2><p>创建一个名为 my-shop-web-ui 的项目，pom.xml 文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>   <span class="tag">&lt;<span class="name">parent</span>&gt;</span>       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.funtl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-shop-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>       <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../my-shop-dependencies/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span>   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-shop-web-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>   <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>   <span class="tag">&lt;<span class="name">name</span>&gt;</span>my-shop-web-ui<span class="tag">&lt;/<span class="name">name</span>&gt;</span>   <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span>   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.funtl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-shop-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>           <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.parent.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="创建接口模块"><a href="#创建接口模块" class="headerlink" title="创建接口模块"></a>创建接口模块</h2><p>创建一个名为 my-shop-web-api 的项目，pom.xml 文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>   <span class="tag">&lt;<span class="name">parent</span>&gt;</span>       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.funtl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-shop-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>       <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../my-shop-dependencies/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span>   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-shop-web-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>   <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>   <span class="tag">&lt;<span class="name">name</span>&gt;</span>my-shop-web-api<span class="tag">&lt;/<span class="name">name</span>&gt;</span>   <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span>   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.funtl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-shop-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>           <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.parent.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>PS：别忘记在 my-shop 工程的 pom.xml 中增加 <module>my-shop-web-api</module> 配置</p><h2 id="根项目的pom-xml"><a href="#根项目的pom-xml" class="headerlink" title="根项目的pom.xml"></a>根项目的pom.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span>         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.funtl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-shop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>    <span class="tag">&lt;<span class="name">modules</span>&gt;</span>        <span class="tag">&lt;<span class="name">module</span>&gt;</span>my-shop-dependencies<span class="tag">&lt;/<span class="name">module</span>&gt;</span>        <span class="tag">&lt;<span class="name">module</span>&gt;</span>my-shop-commons<span class="tag">&lt;/<span class="name">module</span>&gt;</span>        <span class="tag">&lt;<span class="name">module</span>&gt;</span>my-shop-domain<span class="tag">&lt;/<span class="name">module</span>&gt;</span>        <span class="tag">&lt;<span class="name">module</span>&gt;</span>my-shop-web-admin<span class="tag">&lt;/<span class="name">module</span>&gt;</span>        <span class="tag">&lt;<span class="name">module</span>&gt;</span>my-shop-web-ui<span class="tag">&lt;/<span class="name">module</span>&gt;</span>        <span class="tag">&lt;<span class="name">module</span>&gt;</span>my-shop-web-api<span class="tag">&lt;/<span class="name">module</span>&gt;</span>    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="自定义封装返回信息类"><a href="#自定义封装返回信息类" class="headerlink" title="自定义封装返回信息类"></a>自定义封装返回信息类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.funtl.my.shop.commons.dto;<span class="keyword">import</span> java.io.Serializable;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseResult</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span> SUCCESS_STATUS = <span class="number">200</span>;    <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span> SUCCESS_FAIL = <span class="number">500</span>;    <span class="keyword">private</span>  <span class="keyword">int</span> status;    <span class="keyword">private</span> String message;    <span class="comment">/**    **     * <span class="doctag">@Description</span>: 返回成功     * <span class="doctag">@Param</span>: []     * <span class="doctag">@return</span>: com.funtl.my.shop.commons.dto.BaseResult     * <span class="doctag">@Author</span>: kesen    * <span class="doctag">@Date</span>: 2019/6/29 10:34     */</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BaseResult <span class="title">success</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span>  BaseResult.createResult(SUCCESS_STATUS, <span class="string">&quot;成功&quot;</span>);    &#125;       <span class="comment">/**    **     * <span class="doctag">@Description</span>: 返回失败     * <span class="doctag">@Param</span>: []     * <span class="doctag">@return</span>: com.funtl.my.shop.commons.dto.BaseResult     * <span class="doctag">@Author</span>: kesen    * <span class="doctag">@Date</span>: 2019/6/29 10:34     */</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BaseResult <span class="title">fail</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span>  BaseResult.createResult(SUCCESS_FAIL, <span class="string">&quot;失败&quot;</span>);    &#125;    <span class="comment">/**    **     * <span class="doctag">@Description</span>: 自定义成功消息    * <span class="doctag">@Param</span>: [message] 消息内容    * <span class="doctag">@return</span>: com.funtl.my.shop.commons.dto.BaseResult     * <span class="doctag">@Author</span>: kesen    * <span class="doctag">@Date</span>: 2019/6/29 10:34     */</span>     <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  BaseResult <span class="title">success</span><span class="params">(String message)</span> </span>&#123;        <span class="keyword">return</span>  BaseResult.createResult(SUCCESS_STATUS, message);    &#125;    <span class="comment">/**     **     * <span class="doctag">@Description</span>: 自定义失败消息     * <span class="doctag">@Param</span>: [message] 信息内容     * <span class="doctag">@return</span>: com.funtl.my.shop.commons.dto.BaseResult     * <span class="doctag">@Author</span>: kesen     * <span class="doctag">@Date</span>: 2019/6/29 10:34     */</span>    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  BaseResult <span class="title">fail</span><span class="params">(String message)</span> </span>&#123;        <span class="keyword">return</span>  BaseResult.createResult(SUCCESS_FAIL, message);    &#125;    <span class="comment">/**     **     * <span class="doctag">@Description</span>: 自定义失败返回     * <span class="doctag">@Param</span>: [status, message] 状态码 信息内容     * <span class="doctag">@return</span>: com.funtl.my.shop.commons.dto.BaseResult     * <span class="doctag">@Author</span>: kesen     * <span class="doctag">@Date</span>: 2019/6/29 10:34     */</span>    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  BaseResult <span class="title">fail</span><span class="params">(<span class="keyword">int</span> status, String message)</span> </span>&#123;        <span class="keyword">return</span>  BaseResult.createResult(status, message);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStatus</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> status;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(<span class="keyword">int</span> status)</span> </span>&#123;        <span class="keyword">this</span>.status = status;    &#125;    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> message;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;        <span class="keyword">this</span>.message = message;    &#125;    <span class="comment">/**    **     * <span class="doctag">@Description</span>: 创建返回结果信息     * <span class="doctag">@Param</span>: [status, message]     * <span class="doctag">@return</span>: com.funtl.my.shop.commons.dto.BaseResult     * <span class="doctag">@Author</span>: kesen    * <span class="doctag">@Date</span>: 2019/6/29 10:33     */</span>     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span>  BaseResult <span class="title">createResult</span> <span class="params">(<span class="keyword">int</span> status, String message)</span> </span>&#123;        BaseResult baseResult = <span class="keyword">new</span> BaseResult();        baseResult.setStatus(status);        baseResult.setMessage(message);        <span class="keyword">return</span>  baseResult;    &#125;&#125;</span><br></pre></td></tr></table></figure><h1 id="请求转发和重定向"><a href="#请求转发和重定向" class="headerlink" title="请求转发和重定向"></a>请求转发和重定向</h1><h2 id="meta控制页面跳转请求路径为-login"><a href="#meta控制页面跳转请求路径为-login" class="headerlink" title="meta控制页面跳转请求路径为/login"></a>meta控制页面跳转请求路径为<code>/login</code></h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;<span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="comment">&lt;!--head Begin --&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span>    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;1; url=/login&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="处理get请求，得到cookie-并且进行请求转发"><a href="#处理get请求，得到cookie-并且进行请求转发" class="headerlink" title="处理get请求，得到cookie,并且进行请求转发"></a>处理get请求，得到cookie,并且进行请求转发</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;        String userInfo = CookieUtils.getCookieValue(req,COOKIE_NAME_USER_INFO);        System.out.println(<span class="string">&quot;hello&quot;</span>);        <span class="keyword">if</span> (StringUtils.isNotEmpty(userInfo) &amp;&amp; <span class="keyword">null</span> != userInfo) &#123;            String []  cookie = userInfo.split(<span class="string">&quot;:&quot;</span>);            req.setAttribute(<span class="string">&quot;email&quot;</span>, cookie[<span class="number">0</span>]);            req.setAttribute(<span class="string">&quot;password&quot;</span>, cookie[<span class="number">1</span>]);            req.setAttribute(<span class="string">&quot;isRemember&quot;</span>, <span class="keyword">true</span>);        &#125;        req.getRequestDispatcher(<span class="string">&quot;/login.jsp&quot;</span>).forward(req,resp);    &#125;</span><br></pre></td></tr></table></figure><h2 id="处理登录请求（post）"><a href="#处理登录请求（post）" class="headerlink" title="处理登录请求（post）"></a>处理登录请求（post）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        String email = req.getParameter(&quot;email&quot;);        String password = req.getParameter(&quot;password&quot;);        boolean isRemember = req.getParameter(&quot;isRemember&quot;) == null ? false: true;        User admin = userService.login(email, password);        //        if (null != admin) &#123;            if (isRemember) &#123;                //用户信息存储一周                CookieUtils.setCookie(req,resp,COOKIE_NAME_USER_INFO, String.format(&quot;%s:%S&quot;, email, password),7*24*60*60);            &#125;            resp.sendRedirect(&quot;/main.jsp&quot;);        &#125; else &#123;            req.setAttribute(&quot;message&quot;,&quot;账号或者密码错误&quot;);            req.getRequestDispatcher(&quot;/login.jsp&quot;).forward(req, resp);        &#125;    &#125;</span><br></pre></td></tr></table></figure><h2 id="请求转发和请求重定向的区别"><a href="#请求转发和请求重定向的区别" class="headerlink" title="请求转发和请求重定向的区别"></a>请求转发和请求重定向的区别</h2><h4 id="组件之间可否共享信息不同（本质区别）"><a href="#组件之间可否共享信息不同（本质区别）" class="headerlink" title="组件之间可否共享信息不同（本质区别）"></a>组件之间可否共享信息不同（本质区别）</h4><p>当客户端向服务器发送请求时，服务器收到请求后，会将请求封装成一个<code>HttpServletRequest</code>对象request，并且所有的请求参数都封装在request对象中，这个对象时Jsp的内置对象可以直接在Jsp中使用。服务器收到请求后，还需要请求别的页面，这是就有两种方式：请求转发和请求重定向。</p><p>所谓请求转发，是服务器的行为，请求由服务器转发给另外一个页面处理，如何转发，何时转发，转发几次，客户端是不知道的。请求转发时，从发送第一次到最后一次请求的过程中，<code>web容器只创建一次request和response对象</code>，新的页面继续处理同一个请求。也可以理解为服务器将request对象在页面之间传递。</p><p>所谓请求重定向，是客户端的行为，每次请求重定向都是由客户端发起的，也就是说重定向一次，就刷新request对象的属性，之前的request对象的属性值就失效了。</p><h1 id="模块间通信问题"><a href="#模块间通信问题" class="headerlink" title="模块间通信问题"></a>模块间通信问题</h1><h2 id="Apache-HttpClient"><a href="#Apache-HttpClient" class="headerlink" title="Apache HttpClient"></a>Apache HttpClient</h2><h3 id="简易架构图"><a href="#简易架构图" class="headerlink" title="简易架构图"></a>简易架构图</h3><p><img src="https://i.loli.net/2021/11/06/7yICgZKSpEcV1OL.png" alt="Lusifer201807030001"></p><h3 id="Apache-HttpClient-简介"><a href="#Apache-HttpClient-简介" class="headerlink" title="Apache HttpClient 简介"></a>Apache HttpClient 简介</h3><blockquote><p>HttpClient 是 Apache Jakarta Common 下的子项目，用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本和建议。HttpClient 已经应用在很多的项目中，比如 Apache Jakarta 上很著名的另外两个开源项目 Cactus 和 <strong>HTMLUnit</strong> 都使用了 HttpClient。</p></blockquote><p>HttpClient 相比传统 JDK 自带的 <code>URLConnection</code>，增加了易用性和灵活性，它不仅是客户端发送 HTTP 请求变得容易，而且也方便了开发人员测试接口（基于 HTTP 协议的），即提高了开发的效率，也方便提高代码的健壮性。因此熟练掌握 HttpClient 是很重要的必修内容，掌握 HttpClient 后，相信对于 HTTP 协议的了解会更加深入。</p><h3 id="Apache-HttpClient-特性"><a href="#Apache-HttpClient-特性" class="headerlink" title="Apache HttpClient 特性"></a>Apache HttpClient 特性</h3><ul><li>基于标准、纯净的 Java 语言。实现了 HTTP 1.0 和 HTTP 1.1</li><li>以可扩展的面向对象的结构实现了 HTTP 全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE）。</li><li>支持 HTTPS 协议。</li><li>通过 HTTP 代理建立透明的连接。</li><li>利用 CONNECT 方法通过 HTTP 代理建立隧道的 HTTPS 连接。</li><li>Basic, Digest, NTLMv1, NTLMv2, NTLM2 Session, SNPNEGO/Kerberos 认证方案。</li><li>插件式的自定义认证方案。</li><li>便携可靠的套接字工厂使它更容易的使用第三方解决方案。</li><li>连接管理器支持多线程应用。支持设置最大连接数，同时支持设置每个主机的最大连接数，发现并关闭过期的连接。</li><li>自动处理 Set-Cookie 中的 Cookie。</li><li>插件式的自定义 Cookie 策略。</li><li>Request 的输出流可以避免流中内容直接缓冲到 Socket 服务器。</li><li>Response 的输入流可以有效的从 Socket 服务器直接读取相应内容。</li><li>在 HTTP 1.0 和 HTTP 1.1 中利用 KeepAlive 保持持久连接。</li><li>直接获取服务器发送的 response code 和 headers。</li><li>设置连接超时的能力。</li><li>实验性的支持 HTTP 1.1 response caching。</li><li>源代码基于 Apache License 可免费获取</li></ul><h3 id="Apache-HttpClient-使用流程"><a href="#Apache-HttpClient-使用流程" class="headerlink" title="Apache HttpClient 使用流程"></a>Apache HttpClient 使用流程</h3><p>使用 HttpClient 发送请求、接收响应很简单，一般需要如下几步即可。</p><ul><li>创建 <code>HttpClient</code> 对象。</li><li>创建请求方法的实例，并指定请求 URL。如果需要发送 GET 请求，创建 <code>HttpGet</code> 对象；如果需要发送 POST 请求，创建 <code>HttpPost</code> 对象。</li><li>如果需要发送请求参数，可调用 <code>HttpGet</code>、<code>HttpPost</code> 共同的 <code>setParams(HttpParams params)</code> 方法来添加请求参数；对于 <code>HttpPost</code> 对象而言，也可调用 <code>setEntity(HttpEntity entity)</code> 方法来设置请求参数。</li><li>调用 <code>HttpClient</code> 对象的 <code>execute(HttpUriRequest request)</code> 发送请求，该方法返回一个 <code>HttpResponse</code>。</li><li>调用 <code>HttpResponse</code> 的 <code>getAllHeaders()</code>、<code>getHeaders(String name)</code> 等方法可获取服务器的响应头；调用 <code>HttpResponse</code> 的 <code>getEntity()</code> 方法可获取 <code>HttpEntity</code> 对象，该对象包装了服务器的响应内容。程序可通过该对象获取服务器的响应内容。</li><li>释放连接。无论执行方法是否成功，都必须释放连接</li></ul><h3 id="Apache-HttpClient-使用实例"><a href="#Apache-HttpClient-使用实例" class="headerlink" title="Apache HttpClient 使用实例"></a>Apache HttpClient 使用实例</h3><h5 id="POM-1"><a href="#POM-1" class="headerlink" title="POM"></a>POM</h5><p><code>pom.xml</code> 配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Apache Http Begin --&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fluent-hc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpmime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!-- Apache Http End --&gt;</span></span><br></pre></td></tr></table></figure><p>主要增加了 <code>org.apache.httpcomponents:httpclient</code>、<code>org.apache.httpcomponents:fluent-hc</code>、<code>org.apache.httpcomponents:httpmime</code> 三个依赖</p><h5 id="创建-HttpGet-请求"><a href="#创建-HttpGet-请求" class="headerlink" title="创建 HttpGet 请求"></a>创建 HttpGet 请求</h5><p>案例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.funtl.hello.httpclient;<span class="keyword">import</span> org.apache.http.HttpEntity;<span class="keyword">import</span> org.apache.http.client.methods.CloseableHttpResponse;<span class="keyword">import</span> org.apache.http.client.methods.HttpGet;<span class="keyword">import</span> org.apache.http.impl.client.CloseableHttpClient;<span class="keyword">import</span> org.apache.http.impl.client.HttpClients;<span class="keyword">import</span> org.apache.http.util.EntityUtils;<span class="keyword">import</span> java.io.IOException;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        get();    &#125;    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;        <span class="comment">// 创建 HttpClient 客户端        CloseableHttpClient httpClient = HttpClients.createDefault();        // 创建 HttpGet 请求        HttpGet httpGet = new HttpGet(&quot;http://localhost:8080/content/page?draw=1&amp;start=0&amp;length=10&quot;);        // 设置长连接        httpGet.setHeader(&quot;Connection&quot;, &quot;keep-alive&quot;);        // 设置代理（模拟浏览器版本）        httpGet.setHeader(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&quot;);        // 设置 Cookie        httpGet.setHeader(&quot;Cookie&quot;, &quot;UM_distinctid=16442706a09352-0376059833914f-3c604504-1fa400-16442706a0b345; CNZZDATA1262458286=1603637673-1530123020-%7C1530123020; JSESSIONID=805587506F1594AE02DC45845A7216A4&quot;);        CloseableHttpResponse httpResponse = null;        try &#123;            // 请求并获得响应结果            httpResponse = httpClient.execute(httpGet);            HttpEntity httpEntity = httpResponse.getEntity();            // 输出请求结果            System.out.println(EntityUtils.toString(httpEntity));        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        // 无论如何必须关闭连接        finally &#123;            if (httpResponse != null) &#123;                try &#123;                    httpResponse.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (httpClient != null) &#123;                try &#123;                    httpClient.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>控制台输出结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;draw&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;recordsTotal&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;recordsFiltered&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;data&quot;</span>:[&#123;<span class="attr">&quot;id&quot;</span>:<span class="number">33</span>,<span class="attr">&quot;created&quot;</span>:<span class="number">1530542074000</span>,<span class="attr">&quot;updated&quot;</span>:<span class="number">1530542074000</span>,<span class="attr">&quot;title&quot;</span>:<span class="string">&quot;ad1&quot;</span>,<span class="attr">&quot;subTitle&quot;</span>:<span class="string">&quot;ad1&quot;</span>,<span class="attr">&quot;titleDesc&quot;</span>:<span class="string">&quot;ad1&quot;</span>,<span class="attr">&quot;url&quot;</span>:<span class="string">&quot;https://sale.jd.com/act/XkCzhoisOMSW.html&quot;</span>,<span class="attr">&quot;pic&quot;</span>:<span class="string">&quot;https://m.360buyimg.com/babel/jfs/t20164/187/1771326168/92964/b42fade7/5b359ab2N93be3a65.jpg&quot;</span>,<span class="attr">&quot;pic2&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="attr">&quot;content&quot;</span>:<span class="string">&quot;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&quot;</span>,<span class="attr">&quot;tbContentCategory&quot;</span>:&#123;<span class="attr">&quot;id&quot;</span>:<span class="number">89</span>,<span class="attr">&quot;created&quot;</span>:<span class="literal">null</span>,<span class="attr">&quot;updated&quot;</span>:<span class="literal">null</span>,<span class="attr">&quot;parent&quot;</span>:<span class="literal">null</span>,<span class="attr">&quot;isParent&quot;</span>:<span class="literal">null</span>,<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;幻灯片&quot;</span>,<span class="attr">&quot;status&quot;</span>:<span class="literal">null</span>,<span class="attr">&quot;sortOrder&quot;</span>:<span class="literal">null</span>&#125;&#125;],<span class="attr">&quot;error&quot;</span>:<span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure><h5 id="创建-HttpPost-请求"><a href="#创建-HttpPost-请求" class="headerlink" title="创建 HttpPost 请求"></a>创建 HttpPost 请求</h5><p>案例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.funtl.hello.httpclient;<span class="keyword">import</span> org.apache.http.HttpEntity;<span class="keyword">import</span> org.apache.http.client.ClientProtocolException;<span class="keyword">import</span> org.apache.http.client.entity.UrlEncodedFormEntity;<span class="keyword">import</span> org.apache.http.client.methods.CloseableHttpResponse;<span class="keyword">import</span> org.apache.http.client.methods.HttpPost;<span class="keyword">import</span> org.apache.http.impl.client.CloseableHttpClient;<span class="keyword">import</span> org.apache.http.impl.client.HttpClients;<span class="keyword">import</span> org.apache.http.message.BasicNameValuePair;<span class="keyword">import</span> org.apache.http.util.EntityUtils;<span class="keyword">import</span> java.io.IOException;<span class="keyword">import</span> java.io.UnsupportedEncodingException;<span class="keyword">import</span> java.util.ArrayList;<span class="keyword">import</span> java.util.List;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        post();    &#125;    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">()</span> </span>&#123;        <span class="comment">// 创建 HttpClient 客户端        CloseableHttpClient httpClient = HttpClients.createDefault();        // 创建 HttpPost 请求        HttpPost httpPost = new HttpPost(&quot;http://localhost:8080/content/page&quot;);        // 设置长连接        httpPost.setHeader(&quot;Connection&quot;, &quot;keep-alive&quot;);        // 设置代理（模拟浏览器版本）        httpPost.setHeader(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&quot;);        // 设置 Cookie        httpPost.setHeader(&quot;Cookie&quot;, &quot;UM_distinctid=16442706a09352-0376059833914f-3c604504-1fa400-16442706a0b345; CNZZDATA1262458286=1603637673-1530123020-%7C1530123020; JSESSIONID=805587506F1594AE02DC45845A7216A4&quot;);        // 创建 HttpPost 参数        List&lt;BasicNameValuePair&gt; params = new ArrayList&lt;BasicNameValuePair&gt;();        params.add(new BasicNameValuePair(&quot;draw&quot;, &quot;1&quot;));        params.add(new BasicNameValuePair(&quot;start&quot;, &quot;0&quot;));        params.add(new BasicNameValuePair(&quot;length&quot;, &quot;10&quot;));        CloseableHttpResponse httpResponse = null;        try &#123;            // 设置 HttpPost 参数            httpPost.setEntity(new UrlEncodedFormEntity(params, &quot;UTF-8&quot;));            httpResponse = httpClient.execute(httpPost);            HttpEntity httpEntity = httpResponse.getEntity();            // 输出请求结果            System.out.println(EntityUtils.toString(httpEntity));        &#125; catch (UnsupportedEncodingException e) &#123;            e.printStackTrace();        &#125; catch (ClientProtocolException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        // 无论如何必须关闭连接        finally &#123;            try &#123;                if (httpResponse != null) &#123;                    httpResponse.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            try &#123;                if (httpClient != null) &#123;                    httpClient.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>控制台输出结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;draw&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;recordsTotal&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;recordsFiltered&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;data&quot;</span>:[&#123;<span class="attr">&quot;id&quot;</span>:<span class="number">33</span>,<span class="attr">&quot;created&quot;</span>:<span class="number">1530542074000</span>,<span class="attr">&quot;updated&quot;</span>:<span class="number">15305</span></span><br></pre></td></tr></table></figure><h2 id="Jackson"><a href="#Jackson" class="headerlink" title="Jackson"></a>Jackson</h2><h3 id="Jackson-简介"><a href="#Jackson-简介" class="headerlink" title="Jackson 简介"></a>Jackson 简介</h3><p>Jackson 是一个简单基于 Java 应用库，Jackson 可以轻松的将 Java 对象转换成 json 对象和 xml 文档，同样也可以将 json、xml 转换成 Java 对象。Jackson 所依赖的 jar 包较少，简单易用并且性能也要相对高些，并且 Jackson 社区相对比较活跃，更新速度也比较快。</p><h3 id="Jackson-特点"><a href="#Jackson-特点" class="headerlink" title="Jackson 特点"></a>Jackson 特点</h3><ul><li>容易使用 - jackson API 提供了一个高层次外观，以简化常用的用例。</li><li>无需创建映射 - API提供了默认的映射大部分对象序列化。</li><li>性能高 - 快速，低内存占用，适合大型对象图表或系统。</li><li>干净的 JSON - jackson 创建一个干净和紧凑的 JSON 结果，这是让人很容易阅读。</li><li>不依赖 - 库不需要任何其他的库，除了 JDK。</li><li>开源代码 - jackson 是开源的，可以免费使用。</li></ul><h3 id="Jackson-注解"><a href="#Jackson-注解" class="headerlink" title="Jackson 注解"></a>Jackson 注解</h3><p>Jackson 类库包含了很多注解，可以让我们快速建立 Java 类与 JSON 之间的关系。</p><h4 id="JsonProperty"><a href="#JsonProperty" class="headerlink" title="@JsonProperty"></a><code>@JsonProperty</code></h4><p><code>@JsonProperty</code> 注解指定一个属性用于 JSON 映射，默认情况下映射的 JSON 属性与注解的属性名称相同，不过可以使用该注解的 <code>value</code> 值修改 JSON 属性名，该注解还有一个 <code>index</code> 属性指定生成 JSON 属性的顺序，如果有必要的话。</p><h4 id="JsonIgnore"><a href="#JsonIgnore" class="headerlink" title="@JsonIgnore"></a><code>@JsonIgnore</code></h4><p><code>@JsonIgnore</code> 注解用于排除某个属性，这样该属性就不会被 Jackson 序列化和反序列化。</p><h4 id="JsonIgnoreProperties"><a href="#JsonIgnoreProperties" class="headerlink" title="@JsonIgnoreProperties"></a><code>@JsonIgnoreProperties</code></h4><p><code>@JsonIgnoreProperties</code> 注解是类注解。在序列化为 JSON 的时候，<code>@JsonIgnoreProperties(&#123;&quot;prop1&quot;, &quot;prop2&quot;&#125;)</code> 会忽略 <code>pro1</code> 和 <code>pro2</code> 两个属性。在从 JSON 反序列化为 Java 类的时候，<code>@JsonIgnoreProperties(ignoreUnknown=true)</code> 会忽略所有没有 <code>Getter</code> 和 <code>Setter</code> 的属性。该注解在 Java 类和 JSON 不完全匹配的时候很有用。</p><h4 id="JsonIgnoreType"><a href="#JsonIgnoreType" class="headerlink" title="@JsonIgnoreType"></a><code>@JsonIgnoreType</code></h4><p><code>@JsonIgnoreType</code> 也是类注解，会排除所有指定类型的属性。</p><h4 id="JsonPropertyOrder"><a href="#JsonPropertyOrder" class="headerlink" title="@JsonPropertyOrder"></a><code>@JsonPropertyOrder</code></h4><p><code>@JsonPropertyOrder</code> 和 <code>@JsonProperty</code> 的 <code>index</code> 属性类似，指定属性序列化时的顺序。</p><h4 id="JsonRootName"><a href="#JsonRootName" class="headerlink" title="@JsonRootName"></a><code>@JsonRootName</code></h4><p><code>@JsonRootName</code> 注解用于指定 JSON 根属性的名称。</p><h3 id="Jackson-使用实例"><a href="#Jackson-使用实例" class="headerlink" title="Jackson 使用实例"></a>Jackson 使用实例</h3><h4 id="对象的序列化与反序列化"><a href="#对象的序列化与反序列化" class="headerlink" title="对象的序列化与反序列化"></a>对象的序列化与反序列化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.funtl.hello.httpclient;<span class="keyword">import</span> com.fasterxml.jackson.core.JsonParseException;<span class="keyword">import</span> com.fasterxml.jackson.databind.JsonMappingException;<span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;<span class="keyword">import</span> java.io.IOException;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonTester</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">// 创建 ObjectMapper 对象        ObjectMapper mapper = new ObjectMapper();        String jsonString = &quot;&#123;\&quot;name\&quot;:\&quot;Mahesh\&quot;, \&quot;age\&quot;:21&#125;&quot;;        try &#123;            // 反序列化 JSON 到对象            Student student = mapper.readValue(jsonString, Student.class);            System.out.println(student);            // 序列化对象到 JSON            String json = mapper.writeValueAsString(student);            System.out.println(json);        &#125; catch (JsonParseException e) &#123;            e.printStackTrace();        &#125; catch (JsonMappingException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;class Student &#123;    private String name;    private int age;    public Student() &#123;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public String toString() &#123;        return &quot;Student [ name: &quot; + name + &quot;, age: &quot; + age + &quot; ]&quot;;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="集合的序列化与反序列化"><a href="#集合的序列化与反序列化" class="headerlink" title="集合的序列化与反序列化"></a>集合的序列化与反序列化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.funtl.hello.httpclient;<span class="keyword">import</span> com.fasterxml.jackson.databind.JavaType;<span class="keyword">import</span> com.fasterxml.jackson.databind.JsonNode;<span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;<span class="keyword">import</span> java.io.IOException;<span class="keyword">import</span> java.util.ArrayList;<span class="keyword">import</span> java.util.List;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonTester</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">// 创建 ObjectMapper 对象        ObjectMapper mapper = new ObjectMapper();        String jsonString = &quot;&#123;\&quot;draw\&quot;:1,\&quot;recordsTotal\&quot;:1,\&quot;recordsFiltered\&quot;:1,\&quot;data\&quot;:[&#123;\&quot;id\&quot;:33,\&quot;title\&quot;:\&quot;ad1\&quot;,\&quot;subTitle\&quot;:\&quot;ad1\&quot;,\&quot;titleDesc\&quot;:\&quot;ad1\&quot;,\&quot;url\&quot;:\&quot;https://sale.jd.com/act/XkCzhoisOMSW.html\&quot;,\&quot;pic\&quot;:\&quot;https://m.360buyimg.com/babel/jfs/t20164/187/1771326168/92964/b42fade7/5b359ab2N93be3a65.jpg\&quot;,\&quot;pic2\&quot;:\&quot;\&quot;,\&quot;content\&quot;:\&quot;&lt;p&gt;&lt;br&gt;&lt;/p&gt;\&quot;&#125;],\&quot;error\&quot;:null&#125;&quot;;        try &#123;            // 反序列化 JSON 到树            JsonNode jsonNode = mapper.readTree(jsonString);            // 从树中读取 data 节点            JsonNode jsonData = jsonNode.findPath(&quot;data&quot;);            System.out.println(jsonData);            // 反序列化 JSON 到集合            JavaType javaType = mapper.getTypeFactory().constructParametricType(ArrayList.class, TbContent.class);            List&lt;TbContent&gt; tbContents = mapper.readValue(jsonData.toString(), javaType);            for (TbContent tbContent : tbContents) &#123;                System.out.println(tbContent);            &#125;            // 序列化集合到 JSON            String json = mapper.writeValueAsString(tbContents);            System.out.println(json);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;class TbContent &#123;    private Long id;    private String title;    private String subTitle;    private String titleDesc;    private String url;    private String pic;    private String pic2;    private String content;    public Long getId() &#123;        return id;    &#125;    public void setId(Long id) &#123;        this.id = id;    &#125;    public String getTitle() &#123;        return title;    &#125;    public void setTitle(String title) &#123;        this.title = title;    &#125;    public String getSubTitle() &#123;        return subTitle;    &#125;    public void setSubTitle(String subTitle) &#123;        this.subTitle = subTitle;    &#125;    public String getTitleDesc() &#123;        return titleDesc;    &#125;    public void setTitleDesc(String titleDesc) &#123;        this.titleDesc = titleDesc;    &#125;    public String getUrl() &#123;        return url;    &#125;    public void setUrl(String url) &#123;        this.url = url;    &#125;    public String getPic() &#123;        return pic;    &#125;    public void setPic(String pic) &#123;        this.pic = pic;    &#125;    public String getPic2() &#123;        return pic2;    &#125;    public void setPic2(String pic2) &#123;        this.pic2 = pic2;    &#125;    public String getContent() &#123;        return content;    &#125;    public void setContent(String content) &#123;        this.content = content;    &#125;    @Override    public String toString() &#123;        return &quot;TbContent&#123;&quot; +                &quot;id=&quot; + id +                &quot;, title=&#x27;&quot; + title + &#x27;\&#x27;&#x27; +                &quot;, subTitle=&#x27;&quot; + subTitle + &#x27;\&#x27;&#x27; +                &quot;, titleDesc=&#x27;&quot; + titleDesc + &#x27;\&#x27;&#x27; +                &quot;, url=&#x27;&quot; + url + &#x27;\&#x27;&#x27; +                &quot;, pic=&#x27;&quot; + pic + &#x27;\&#x27;&#x27; +                &quot;, pic2=&#x27;&quot; + pic2 + &#x27;\&#x27;&#x27; +                &quot;, content=&#x27;&quot; + content + &#x27;\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="各种对象的理解"><a href="#各种对象的理解" class="headerlink" title="各种对象的理解"></a>各种对象的理解</h2><p><img src="https://i.loli.net/2021/11/06/76fYm8XKkizcUqZ.png" alt="image-20210110191231278"></p><h2 id="你怎么理解-RESTful"><a href="#你怎么理解-RESTful" class="headerlink" title="你怎么理解 RESTful"></a>你怎么理解 RESTful</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>2000 年，Roy Thomas Fielding 博士在他那篇著名的博士论文《Architectural Styles and the Design of Network-based Software Architectures》中提出了几种软件应用的架构风格，REST 作为其中的一种架构风格在这篇论文的第5章中进行了概括性的介绍。</p><p>REST 是“REpresentational State Transfer”的缩写，可以翻译成“表现状态转换”，但是在绝大多数场合中我们只说 REST 或者 RESTful。Fielding 在论文中将 REST 定位为“分布式超媒体应用（Distributed Hypermedia System）”的架构风格，它在文中提到一个名为“HATEOAS（Hypermedia as the engine of application state）”的概念。</p><p>我们利用一个面向最终用户的 Web 应用来对这个概念进行简单阐述：这里所谓的应用状态（Application State）表示 Web 应用的客户端的状态，简单起见可以理解为会话状态。资源在浏览器中以超媒体的形式呈现，通过点击超媒体中的链接可以获取其它相关的资源或者对当前资源进行相应的处理，获取的资源或者针对资源处理的响应同样以超媒体的形式再次呈现在浏览器上。由此可见，超媒体成为了驱动客户端会话状态的转换的引擎。</p><p>借助于超媒体这种特殊的资源呈现方式，应用状态的转换体现为浏览器中呈现资源的转换。如果将超媒体进一步抽象成一般意义上的资源呈现（Representation ）方式，那么应用状态变成了可被呈现的状态（REpresentational State）。应用状态之间的转换就成了可被呈现的状态装换（REpresentational State Transfer），这就是 REST。</p><p>REST 是一种很笼统的概念，它代表一种架构风格</p><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>在 RESTful API 中，API 接口应该尽量兼容之前的版本。但是，在实际业务开发场景中，可能随着业务需求的不断迭代，现有的 API 接口无法支持旧版本的适配，此时如果强制升级服务端的 API 接口将导致客户端旧有功能出现故障。实际上，Web 端是部署在服务器，因此它可以很容易为了适配服务端的新的 API 接口进行版本升级，然而像 Android 端、IOS 端、PC 端等其他客户端是运行在用户的机器上，因此当前产品很难做到适配新的服务端的 API 接口，从而出现功能故障，这种情况下，用户必须升级产品到最新的版本才能正常使用。</p><p>为了解决这个版本不兼容问题，在设计 RESTful API 的一种实用的做法是使用版本号。一般情况下，我们会在 url 中保留版本号，并同时兼容多个版本。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【GET】  /v1/users/&#123;user_id&#125;  // 版本 v1 的查询用户列表的 API 接口【GET】  /v2/users/&#123;user_id&#125;  // 版本 v2 的查询用户列表的 API 接口</span><br></pre></td></tr></table></figure><p>现在，我们可以不改变版本 v1 的查询用户列表的 API 接口的情况下，新增版本 v2 的查询用户列表的 API 接口以满足新的业务需求，此时，客户端的产品的新功能将请求新的服务端的 API 接口地址。虽然服务端会同时兼容多个版本，但是同时维护太多版本对于服务端而言是个不小的负担，因为服务端要维护多套代码。这种情况下，常见的做法不是维护所有的兼容版本，而是只维护最新的几个兼容版本，例如维护最新的三个兼容版本。在一段时间后，当绝大多数用户升级到较新的版本后，废弃一些使用量较少的服务端的老版本API 接口版本，并要求使用产品的非常旧的版本的用户强制升级。</p><p>注意的是，“不改变版本 v1 的查询用户列表的 API 接口”主要指的是对于客户端的调用者而言它看起来是没有改变。而实际上，如果业务变化太大，服务端的开发人员需要对旧版本的 API 接口使用适配器模式将请求适配到新的API 接口上。</p><h3 id="资源路径"><a href="#资源路径" class="headerlink" title="资源路径"></a>资源路径</h3><p>RESTful API 的设计以资源为核心，每一个 URI 代表一种资源。因此，URI 不能包含动词，只能是名词。注意的是，形容词也是可以使用的，但是尽量少用。一般来说，不论资源是单个还是多个，API 的名词要以复数进行命名。此外，命名名词的时候，要使用小写、数字及下划线来区分多个单词。这样的设计是为了与 json 对象及属性的命名方案保持一致。例如，一个查询系统标签的接口可以进行如下设计。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【GET】  /v1/tags/&#123;tag_id&#125; </span><br></pre></td></tr></table></figure><p>1</p><p>同时，资源的路径应该从根到子依次如下</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/&#123;resources&#125;/&#123;resource_id&#125;/&#123;sub_resources&#125;/&#123;sub_resource_id&#125;/&#123;sub_resource_property&#125;</span><br></pre></td></tr></table></figure><p>1</p><p>我们来看一个“添加用户的角色”的设计，其中“用户”是主资源，“角色”是子资源。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【POST】  /v1/users/&#123;user_id&#125;/roles/&#123;role_id&#125; // 添加用户的角色</span><br></pre></td></tr></table></figure><p>1</p><p>有的时候，当一个资源变化难以使用标准的 RESTful API 来命名，可以考虑使用一些特殊的 actions 命名。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/&#123;resources&#125;/&#123;resource_id&#125;/actions/&#123;action&#125;</span><br></pre></td></tr></table></figure><p>1</p><p>举个例子，“密码修改”这个接口的命名很难完全使用名词来构建路径，此时可以引入 action 命名。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【PUT】  /v1/users/&#123;user_id&#125;/password/actions/modify // 密码修改</span><br></pre></td></tr></table></figure><h3 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h3><p>可以通过 GET、 POST、 PUT、 PATCH、 DELETE 等方式对服务端的资源进行操作。其中：</p><ul><li>GET：用于查询资源</li><li>POST：用于创建资源</li><li>PUT：用于更新服务端的资源的全部信息</li><li>PATCH：用于更新服务端的资源的部分信息</li><li>DELETE：用于删除服务端的资源。</li></ul><p>这里，使用“用户”的案例进行回顾通过 GET、 POST、 PUT、 PATCH、 DELETE 等方式对服务端的资源进行操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【GET】          /users                # 查询用户信息列表【GET】          /users/1001           # 查看某个用户信息【POST】         /users                # 新建用户信息【PUT】          /users/1001           # 更新用户信息(全部字段)【PATCH】        /users/1001           # 更新用户信息(部分字段)【DELETE】       /users/1001           # 删除用户信息</span><br></pre></td></tr></table></figure><h3 id="查询参数"><a href="#查询参数" class="headerlink" title="查询参数"></a>查询参数</h3><p>RESTful API 接口应该提供参数，过滤返回结果。其中，offset 指定返回记录的开始位置。一般情况下，它会结合 limit 来做分页的查询，这里 limit 指定返回记录的数量。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【GET】  /&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;?offset=0&amp;limit=20</span><br></pre></td></tr></table></figure><p>1</p><p>同时，orderby 可以用来排序，但仅支持单个字符的排序，如果存在多个字段排序，需要业务中扩展其他参数进行支持。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【GET】  /&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;?orderby=&#123;field&#125; [asc|desc]</span><br></pre></td></tr></table></figure><p>1</p><p>为了更好地选择是否支持查询总数，我们可以使用 count 字段，count 表示返回数据是否包含总条数，它的默认值为 false。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【GET】  /&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;?count=[true|false]</span><br></pre></td></tr></table></figure><p>1</p><p>上面介绍的 offset、 limit、 orderby 是一些公共参数。此外，业务场景中还存在许多个性化的参数。我们来看一个例子。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【GET】  /v1/categorys/&#123;category_id&#125;/apps/&#123;app_id&#125;?enable=[1|0]&amp;os_type=&#123;field&#125;&amp;device_ids=&#123;field,field,…&#125;</span><br></pre></td></tr></table></figure><p>1</p><p>注意的是，不要过度设计，只返回用户需要的查询参数。此外，需要考虑是否对查询参数创建数据库索引以提高查询性能</p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>使用适合的状态码很重要，而不应该全部都返回状态码 200，或者随便乱使用。这里，列举在实际开发过程中常用的一些状态码，以供参考。</p><table><thead><tr><th>状态码</th><th>描述</th></tr></thead><tbody><tr><td>200</td><td>请求成功</td></tr><tr><td>201</td><td>创建成功</td></tr><tr><td>400</td><td>错误的请求</td></tr><tr><td>401</td><td>未验证</td></tr><tr><td>403</td><td>被拒绝</td></tr><tr><td>404</td><td>无法找到</td></tr><tr><td>409</td><td>资源冲突</td></tr><tr><td>500</td><td>服务器内部错误</td></tr></tbody></table><h3 id="异常响应"><a href="#异常响应" class="headerlink" title="异常响应"></a>异常响应</h3><p>当 RESTful API 接口出现非 2xx 的 HTTP 错误码响应时，采用全局的异常结构响应信息。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">400</span> Bad RequestContent-Type: application/json&#123;    &quot;code&quot;: &quot;INVALID_ARGUMENT&quot;,    &quot;message&quot;: &quot;&#123;error message&#125;&quot;,    &quot;cause&quot;: &quot;&#123;cause message&#125;&quot;,    &quot;request_id&quot;: &quot;01234567-89ab-cdef-0123-456789abcdef&quot;,    &quot;host_id&quot;: &quot;&#123;server identity&#125;&quot;,    &quot;server_time&quot;: &quot;2014-01-01T12:00:00Z&quot;&#125;</span><br></pre></td></tr></table></figure><h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><p>在设计服务端的 RESTful API 的时候，我们还需要对请求参数进行限制说明。例如一个支持批量查询的接口，我们要考虑最大支持查询的数量。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【GET】     /v1/users/batch?user_ids=1001,1002      // 批量查询用户信息参数说明- user_ids: 用户ID串，最多允许 20 个。</span><br></pre></td></tr></table></figure><p>此外，在设计新增或修改接口时，我们还需要在文档中明确告诉调用者哪些参数是必填项，哪些是选填项，以及它们的边界值的限制。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【POST】     /v1/users                             <span class="comment">// 创建用户信息请求内容&#123;    &quot;username&quot;: &quot;lusifer&quot;,                 // 必填, 用户名称, max 10    &quot;realname&quot;: &quot;鲁斯菲尔&quot;,               // 必填, 用户名称, max 10    &quot;password&quot;: &quot;123456&quot;,              // 必填, 用户密码, max 32    &quot;email&quot;: &quot;topsale@vip.qq.com&quot;,     // 选填, 电子邮箱, max 32    &quot;weixin&quot;: &quot;Lusifer&quot;,            // 选填，微信账号, max 32    &quot;sex&quot;: 1                           // 必填, 用户性别[1-男 2-女 99-未知]&#125;</span></span><br></pre></td></tr></table></figure><h3 id="响应参数"><a href="#响应参数" class="headerlink" title="响应参数"></a>响应参数</h3><p>针对不同操作，服务端向用户返回的结果应该符合以下规范。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【GET】     /&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;      // 返回单个资源对象【GET】     /&#123;version&#125;/&#123;resources&#125;                    // 返回资源对象的列表【POST】    /&#123;version&#125;/&#123;resources&#125;                    // 返回新生成的资源对象【PUT】     /&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;      // 返回完整的资源对象【PATCH】   /&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;      // 返回完整的资源对象【DELETE】  /&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;      // 状态码 200，返回完整的资源对象。                                                      // 状态码 204，返回一个空文档</span><br></pre></td></tr></table></figure><p>如果是单条数据，则返回一个对象的 JSON 字符串。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK&#123;    &quot;id&quot; : &quot;01234567-89ab-cdef-0123-456789abcdef&quot;,    &quot;name&quot; : &quot;example&quot;,    &quot;created_time&quot;: 1496676420000,    &quot;updated_time&quot;: 1496676420000,    ...&#125;</span><br></pre></td></tr></table></figure><p>如果是列表数据，则返回一个封装的结构体。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK&#123;    &quot;count&quot;:<span class="number">100</span>,    &quot;items&quot;:[        &#123;            &quot;id&quot; : &quot;01234567-89ab-cdef-0123-456789abcdef&quot;,            &quot;name&quot; : &quot;example&quot;,            &quot;created_time&quot;: 1496676420000,            &quot;updated_time&quot;: 1496676420000,            ...        &#125;,        ...    ]&#125;</span><br></pre></td></tr></table></figure><h3 id="一个完整的案例"><a href="#一个完整的案例" class="headerlink" title="一个完整的案例"></a>一个完整的案例</h3><p>最后，我们使用一个完整的案例将前面介绍的知识整合起来。这里，使用“获取用户列表”的案例。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【GET】     /v1/users?[&amp;keyword=xxx][&amp;enable=1][&amp;offset=0][&amp;limit=20] 获取用户列表功能说明：获取用户列表请求方式：GET参数说明- keyword: 模糊查找的关键字。[选填]- enable: 启用状态[1-启用 2-禁用]。[选填]- offset: 获取位置偏移，从 0 开始。[选填]- limit: 每次获取返回的条数，缺省为 20 条，最大不超过 100。 [选填]响应内容HTTP/1.1 200 OK&#123;    &quot;count&quot;:100,    &quot;items&quot;:[        &#123;            &quot;id&quot; : &quot;01234567-89ab-cdef-0123-456789abcdef&quot;,            &quot;name&quot; : &quot;example&quot;,            &quot;created_time&quot;: 1496676420000,            &quot;updated_time&quot;: 1496676420000,            ...        &#125;,        ...    ]&#125;失败响应HTTP/1.1 403 UC/AUTH_DENIEDContent-Type: application/json&#123;    &quot;code&quot;: &quot;INVALID_ARGUMENT&quot;,    &quot;message&quot;: &quot;&#123;error message&#125;&quot;,    &quot;cause&quot;: &quot;&#123;cause message&#125;&quot;,    &quot;request_id&quot;: &quot;01234567-89ab-cdef-0123-456789abcdef&quot;,    &quot;host_id&quot;: &quot;&#123;server identity&#125;&quot;,    &quot;server_time&quot;: &quot;2014-01-01T12:00:00Z&quot;&#125;错误代码- 403 UC/AUTH_DENIED    授权受限</span><br></pre></td></tr></table></figure><h2 id="什么是幂等性"><a href="#什么是幂等性" class="headerlink" title="什么是幂等性"></a>什么是幂等性</h2><p>HTTP 幂等方法，是指无论调用多少次都不会有不同结果的 HTTP 方法。不管你调用一次，还是调用一百次，一千次，结果都是相同的。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET     /tickets       # 获取ticket列表GET     /tickets/12    # 查看某个具体的ticketPOST    /tickets       # 新建一个ticketPUT     /tickets/12    # 更新ticket 12PATCH   /tickets/12    # 更新ticket 12DELETE  /tickets/12    # 删除ticekt 12</span><br></pre></td></tr></table></figure><h3 id="HTTP-GET-方法"><a href="#HTTP-GET-方法" class="headerlink" title="HTTP GET 方法"></a>HTTP GET 方法</h3><p>HTTP GET 方法，用于获取资源，不管调用多少次接口，结果都不会改变，所以是幂等的。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET     /tickets       # 获取ticket列表GET     /tickets/12    # 查看某个具体的ticket</span><br></pre></td></tr></table></figure><p>只是查询数据，不会影响到资源的变化，因此我们认为它幂等。</p><p>值得注意，幂等性指的是作用于结果而非资源本身。怎么理解呢？例如，这个 HTTP GET 方法可能会每次得到不同的返回内容，但并不影响资源。</p><p>可能你会问有这种情况么？当然有咯。例如，我们有一个接口获取当前时间，我们就应该设计成</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET     /service_time # 获取服务器当前时间</span><br></pre></td></tr></table></figure><p>它本身不会对资源本身产生影响，因此满足幂等性。</p><h3 id="HTTP-POST-方法"><a href="#HTTP-POST-方法" class="headerlink" title="HTTP POST 方法"></a>HTTP POST 方法</h3><p>HTTP POST 方法是一个非幂等方法，因为调用多次，都将产生新的资源。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST    /tickets       # 新建一个ticket</span><br></pre></td></tr></table></figure><p>因为它会对资源本身产生影响，每次调用都会有新的资源产生，因此不满足幂等性。</p><h3 id="HTTP-PUT-方法"><a href="#HTTP-PUT-方法" class="headerlink" title="HTTP PUT 方法"></a>HTTP PUT 方法</h3><p>HTTP PUT 方法是不是幂等的呢？我们来看下</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT     /tickets/12    # 更新ticket 12</span><br></pre></td></tr></table></figure><p>因为它直接把实体部分的数据替换到服务器的资源，我们多次调用它，只会产生一次影响，但是有相同结果的 HTTP 方法，所以满足幂等性</p><h3 id="HTTP-PATCH-方法"><a href="#HTTP-PATCH-方法" class="headerlink" title="HTTP PATCH 方法"></a>HTTP PATCH 方法</h3><p>HTTP PATCH 方法是非幂等的。HTTP POST 方法和 HTTP PUT 方法可能比较好理解，但是 HTTP PATCH 方法只是更新部分资源，怎么是非幂等的呢?</p><p>因为，PATCH 提供的实体则需要根据程序或其它协议的定义，解析后在服务器上执行，以此来修改服务器上的资源。换句话说，PATCH 请求是会执行某个程序的，如果重复提交，程序可能执行多次，对服务器上的资源就可能造成额外的影响，这就可以解释它为什么是非幂等的了。</p><p>可能你还不能理解这点。我们举个例子</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATCH   /tickets/12    # 更新ticket 12</span><br></pre></td></tr></table></figure><p>此时，我们服务端对方法的处理是，当调用一次方法，更新部分字段，将这条 ticket 记录的操作记录加一，这次，每次调用的资源是不是变了呢，所以它是有可能是非幂等的操作</p><h3 id="HTTP-DELETE-方法"><a href="#HTTP-DELETE-方法" class="headerlink" title="HTTP DELETE 方法"></a>HTTP DELETE 方法</h3><p>HTTP DELETE 方法用于删除资源，会将资源删除。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE  /tickets/12    # 删除ticekt 12</span><br></pre></td></tr></table></figure><p>调用一次和多次对资源产生影响是相同的，所以也满足幂等性。</p><h3 id="如何设计符合幂等性的高质量-RESTful-API"><a href="#如何设计符合幂等性的高质量-RESTful-API" class="headerlink" title="如何设计符合幂等性的高质量 RESTful API"></a>如何设计符合幂等性的高质量 RESTful API</h3><h4 id="HTTP-GET-vs-HTTP-POST"><a href="#HTTP-GET-vs-HTTP-POST" class="headerlink" title="HTTP GET vs HTTP POST"></a>HTTP GET vs HTTP POST</h4><p>也许，你会想起一个面试题。<strong>HTTP 请求的 GET 与 POST 方式有什么区别？</strong> 你可能会回答到：GET 方式通过 URL 提交数据，数据在 URL 中可以看到；POST 方式，数据放置在 HTML HEADER 内提交。但是，我们现在从 RESTful 的资源角度来看待问题，HTTP GET 方法是幂等的，所以它适合作为查询操作，HTTP POST 方法是非幂等的，所以用来表示新增操作。</p><p>但是，也有例外，我们有的时候可能需要把查询方法改造成 HTTP POST 方法。比如，超长（1k）的 GET URL 使用 POST 方法来替代，因为 GET 受到 URL 长度的限制。虽然，它不符合幂等性，但是它是一种折中的方案。</p><h4 id="HTTP-POST-vs-HTTP-PUT"><a href="#HTTP-POST-vs-HTTP-PUT" class="headerlink" title="HTTP POST vs HTTP PUT"></a>HTTP POST vs HTTP PUT</h4><p>对于 HTTP POST 方法和 HTTP PUT 方法，我们一般的理解是 POST 表示创建资源，PUT 表示更新资源。当然，这个是正确的理解。</p><p>但是，实际上，两个方法都用于创建资源，更为本质的差别是在幂等性。HTTP POST 方法是非幂等，所以用来表示创建资源，HTTP PUT 方法是幂等的，因此表示更新资源更加贴切。</p><h4 id="HTTP-PUT-vs-HTTP-PATCH"><a href="#HTTP-PUT-vs-HTTP-PATCH" class="headerlink" title="HTTP PUT vs HTTP PATCH"></a>HTTP PUT vs HTTP PATCH</h4><p>此时，你看会有另外一个问题。HTTP PUT 方法和 HTTP PATCH 方法，都是用来表述更新资源，它们之间有什么区别呢？我们一般的理解是 PUT 表示更新全部资源，PATCH 表示更新部分资源。首先，这个是我们遵守的第一准则。根据上面的描述，PATCH 方法是非幂等的，因此我们在设计我们服务端的 RESTful API 的时候，也需要考虑。如果，我们想要明确的告诉调用者我们的资源是幂等的，我的设计更倾向于使用 HTTP PUT 方法。</p><p><img src="https://i.loli.net/2021/11/06/yhd8HWYjxP7iOfk.png" alt="image-20210110202508767"></p><p><img src="https://i.loli.net/2021/11/06/6HoDFqh138pCIeN.png" alt="image-20210110202610244"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SSM框架搭建项目&quot;&gt;&lt;a href=&quot;#SSM框架搭建项目&quot; class=&quot;headerlink&quot; title=&quot;SSM框架搭建项目&quot;&gt;&lt;/a&gt;SSM框架搭建项目&lt;/h1&gt;&lt;h4 id=&quot;Spring-SpringMVC-Mybatis&quot;&gt;&lt;a href=&quot;#S</summary>
      
    
    
    
    <category term="spring技术" scheme="http://example.com/categories/spring%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="ssm框架搭建" scheme="http://example.com/tags/ssm%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
</feed>
